--------------------------------------------------------------------------------
I1 cache:         32768 B, 64 B, 8-way associative
D1 cache:         49152 B, 64 B, 12-way associative
LL cache:         18874368 B, 64 B, 18-way associative
Command:          ./P2.out input/input-profiling.txt
Data file:        cachegrind.out.188862
Events recorded:  Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Events shown:     Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Event sort order: Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Thresholds:       0.1 100 100 100 100 100 100 100 100
Include dirs:     
User annotated:   
Auto-annotation:  on

--------------------------------------------------------------------------------
Ir                      I1mr           ILmr           Dr                     D1mr            DLmr           Dw                   D1mw           DLmw           
--------------------------------------------------------------------------------
21,892,586,596 (100.0%) 2,851 (100.0%) 2,378 (100.0%) 3,588,726,993 (100.0%) 12,806 (100.0%) 7,553 (100.0%) 985,447,801 (100.0%) 2,408 (100.0%) 1,528 (100.0%)  PROGRAM TOTALS

--------------------------------------------------------------------------------
Ir                     I1mr         ILmr         Dr                     D1mr           DLmr           Dw                   D1mw           DLmw          file:function
--------------------------------------------------------------------------------
6,822,882,064 (31.17%)   3 ( 0.11%)   3 ( 0.13%)   650,120,516 (18.12%)     0              0          325,320,516 (33.01%)     0            0           /usr/include/c++/12/bits/random.tcc:random_movement(int&, int&, int&, std::vector<double, std::allocator<double> >&, std::mersenne_twister_engine<unsigned long, 32ul, 624ul, 397ul, 31ul, 2567483615ul, 11ul, 4294967295ul, 7ul, 2636928640ul, 15ul, 4022730752ul, 18ul, 1812433253ul>&, std::uniform_int_distribution<int>&)
6,111,939,081 (27.92%)   6 ( 0.21%)   6 ( 0.25%) 1,633,807,314 (45.53%)     1 ( 0.01%)     1 ( 0.01%) 332,108,000 (33.70%)     0            0           /home/jovyan/Proyecto-intermedio-entropia/code/random_movement.cpp:random_movement(int&, int&, int&, std::vector<double, std::allocator<double> >&, std::mersenne_twister_engine<unsigned long, 32ul, 624ul, 397ul, 31ul, 2567483615ul, 11ul, 4294967295ul, 7ul, 2636928640ul, 15ul, 4022730752ul, 18ul, 1812433253ul>&, std::uniform_int_distribution<int>&)
5,039,359,585 (23.02%)   4 ( 0.14%)   4 ( 0.17%)   651,686,032 (18.16%)     0              0          325,322,500 (33.01%)     0            0           /usr/include/c++/12/bits/random.tcc:std::mersenne_twister_engine<unsigned long, 32ul, 624ul, 397ul, 31ul, 2567483615ul, 11ul, 4294967295ul, 7ul, 2636928640ul, 15ul, 4022730752ul, 18ul, 1812433253ul>::_M_gen_rand()
3,254,496,000 (14.87%)   2 ( 0.07%)   2 ( 0.08%)   325,612,000 ( 9.07%)     0              0            1,624,000 ( 0.16%)     0            0           /usr/include/c++/12/bits/uniform_int_dist.h:random_movement(int&, int&, int&, std::vector<double, std::allocator<double> >&, std::mersenne_twister_engine<unsigned long, 32ul, 624ul, 397ul, 31ul, 2567483615ul, 11ul, 4294967295ul, 7ul, 2636928640ul, 15ul, 4022730752ul, 18ul, 1812433253ul>&, std::uniform_int_distribution<int>&)
  649,600,000 ( 2.97%)   0            0            324,800,000 ( 9.05%)     0              0                    0              0            0           /usr/include/c++/12/bits/stl_vector.h:random_movement(int&, int&, int&, std::vector<double, std::allocator<double> >&, std::mersenne_twister_engine<unsigned long, 32ul, 624ul, 397ul, 31ul, 2567483615ul, 11ul, 4294967295ul, 7ul, 2636928640ul, 15ul, 4022730752ul, 18ul, 1812433253ul>&, std::uniform_int_distribution<int>&)

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/12/bits/stl_vector.h
--------------------------------------------------------------------------------
Ir                   I1mr       ILmr       Dr                   D1mr       DLmr       Dw           D1mw       DLmw       

-- line 92 ----------------------------------------
          .          .          .                    .          .          .            .          .          .                 struct _Vector_impl_data
          .          .          .                    .          .          .            .          .          .                 {
          .          .          .                    .          .          .            .          .          .           	pointer _M_start;
          .          .          .                    .          .          .            .          .          .           	pointer _M_finish;
          .          .          .                    .          .          .            .          .          .           	pointer _M_end_of_storage;
          .          .          .                    .          .          .            .          .          .           
          .          .          .                    .          .          .            .          .          .           	_GLIBCXX20_CONSTEXPR
          .          .          .                    .          .          .            .          .          .           	_Vector_impl_data() _GLIBCXX_NOEXCEPT
         15 ( 0.00%) 0          0                    0          0          0            8 ( 0.00%) 1 ( 0.04%) 0           	: _M_start(), _M_finish(), _M_end_of_storage()
          .          .          .                    .          .          .            .          .          .           	{ }
          .          .          .                    .          .          .            .          .          .           
          .          .          .                    .          .          .            .          .          .           #if __cplusplus >= 201103L
          .          .          .                    .          .          .            .          .          .           	_GLIBCXX20_CONSTEXPR
          .          .          .                    .          .          .            .          .          .           	_Vector_impl_data(_Vector_impl_data&& __x) noexcept
          .          .          .                    .          .          .            .          .          .           	: _M_start(__x._M_start), _M_finish(__x._M_finish),
          .          .          .                    .          .          .            .          .          .           	  _M_end_of_storage(__x._M_end_of_storage)
          .          .          .                    .          .          .            .          .          .           	{ __x._M_start = __x._M_finish = __x._M_end_of_storage = pointer(); }
-- line 108 ----------------------------------------
-- line 359 ----------------------------------------
          .          .          .                    .          .          .            .          .          .                 : _M_impl(_Tp_alloc_type(__a), std::move(__x._M_impl))
          .          .          .                    .          .          .            .          .          .                 { }
          .          .          .                    .          .          .            .          .          .           #endif
          .          .          .                    .          .          .            .          .          .           
          .          .          .                    .          .          .            .          .          .                 _GLIBCXX20_CONSTEXPR
          .          .          .                    .          .          .            .          .          .                 ~_Vector_base() _GLIBCXX_NOEXCEPT
          .          .          .                    .          .          .            .          .          .                 {
          .          .          .                    .          .          .            .          .          .           	_M_deallocate(_M_impl._M_start,
          8 ( 0.00%) 0          0                    4 ( 0.00%) 0          0            0          0          0           		      _M_impl._M_end_of_storage - _M_impl._M_start);
          .          .          .                    .          .          .            .          .          .                 }
          .          .          .                    .          .          .            .          .          .           
          .          .          .                    .          .          .            .          .          .               public:
          .          .          .                    .          .          .            .          .          .                 _Vector_impl _M_impl;
          .          .          .                    .          .          .            .          .          .           
          .          .          .                    .          .          .            .          .          .                 _GLIBCXX20_CONSTEXPR
          .          .          .                    .          .          .            .          .          .                 pointer
          .          .          .                    .          .          .            .          .          .                 _M_allocate(size_t __n)
          .          .          .                    .          .          .            .          .          .                 {
          .          .          .                    .          .          .            .          .          .           	typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
          8 ( 0.00%) 0          0                    0          0          0            0          0          0           	return __n != 0 ? _Tr::allocate(_M_impl, __n) : pointer();
          .          .          .                    .          .          .            .          .          .                 }
          .          .          .                    .          .          .            .          .          .           
          .          .          .                    .          .          .            .          .          .                 _GLIBCXX20_CONSTEXPR
          .          .          .                    .          .          .            .          .          .                 void
          .          .          .                    .          .          .            .          .          .                 _M_deallocate(pointer __p, size_t __n)
          .          .          .                    .          .          .            .          .          .                 {
          .          .          .                    .          .          .            .          .          .           	typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
         12 ( 0.00%) 0          0                    0          0          0            0          0          0           	if (__p)
          .          .          .                    .          .          .            .          .          .           	  _Tr::deallocate(_M_impl, __p, __n);
          .          .          .                    .          .          .            .          .          .                 }
          .          .          .                    .          .          .            .          .          .           
          .          .          .                    .          .          .            .          .          .               protected:
          .          .          .                    .          .          .            .          .          .                 _GLIBCXX20_CONSTEXPR
          .          .          .                    .          .          .            .          .          .                 void
          .          .          .                    .          .          .            .          .          .                 _M_create_storage(size_t __n)
          .          .          .                    .          .          .            .          .          .                 {
          4 ( 0.00%) 0          0                    0          0          0            4 ( 0.00%) 0          0           	this->_M_impl._M_start = this->_M_allocate(__n);
          .          .          .                    .          .          .            .          .          .           	this->_M_impl._M_finish = this->_M_impl._M_start;
         11 ( 0.00%) 1 ( 0.04%) 1 ( 0.04%)           0          0          0            4 ( 0.00%) 0          0           	this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
          .          .          .                    .          .          .            .          .          .                 }
          .          .          .                    .          .          .            .          .          .               };
          .          .          .                    .          .          .            .          .          .           
          .          .          .                    .          .          .            .          .          .             /**
          .          .          .                    .          .          .            .          .          .              *  @brief A standard container which offers fixed time access to
          .          .          .                    .          .          .            .          .          .              *  individual elements in any order.
          .          .          .                    .          .          .            .          .          .              *
          .          .          .                    .          .          .            .          .          .              *  @ingroup sequences
-- line 405 ----------------------------------------
-- line 556 ----------------------------------------
          .          .          .                    .          .          .            .          .          .                  *  @brief  Creates a %vector with copies of an exemplar element.
          .          .          .                    .          .          .            .          .          .                  *  @param  __n  The number of elements to initially create.
          .          .          .                    .          .          .            .          .          .                  *  @param  __value  An element to copy.
          .          .          .                    .          .          .            .          .          .                  *  @param  __a  An allocator.
          .          .          .                    .          .          .            .          .          .                  *
          .          .          .                    .          .          .            .          .          .                  *  This constructor fills the %vector with @a __n copies of @a __value.
          .          .          .                    .          .          .            .          .          .                  */
          .          .          .                    .          .          .            .          .          .                 _GLIBCXX20_CONSTEXPR
          9 ( 0.00%) 0          0                    0          0          0            9 ( 0.00%) 0          0                 vector(size_type __n, const value_type& __value,
          .          .          .                    .          .          .            .          .          .           	     const allocator_type& __a = allocator_type())
          .          .          .                    .          .          .            .          .          .                 : _Base(_S_check_init_len(__n, __a), __a)
         12 ( 0.00%) 0          0                   12 ( 0.00%) 0          0            0          0          0                 { _M_fill_initialize(__n, __value); }
          .          .          .                    .          .          .            .          .          .           #else
          .          .          .                    .          .          .            .          .          .                 /**
          .          .          .                    .          .          .            .          .          .                  *  @brief  Creates a %vector with copies of an exemplar element.
          .          .          .                    .          .          .            .          .          .                  *  @param  __n  The number of elements to initially create.
          .          .          .                    .          .          .            .          .          .                  *  @param  __value  An element to copy.
          .          .          .                    .          .          .            .          .          .                  *  @param  __a  An allocator.
          .          .          .                    .          .          .            .          .          .                  *
          .          .          .                    .          .          .            .          .          .                  *  This constructor fills the %vector with @a __n copies of @a __value.
-- line 575 ----------------------------------------
-- line 722 ----------------------------------------
          .          .          .                    .          .          .            .          .          .                  *  The dtor only erases the elements, and note that if the
          .          .          .                    .          .          .            .          .          .                  *  elements themselves are pointers, the pointed-to memory is
          .          .          .                    .          .          .            .          .          .                  *  not touched in any way.  Managing the pointer is the user's
          .          .          .                    .          .          .            .          .          .                  *  responsibility.
          .          .          .                    .          .          .            .          .          .                  */
          .          .          .                    .          .          .            .          .          .                 _GLIBCXX20_CONSTEXPR
          .          .          .                    .          .          .            .          .          .                 ~vector() _GLIBCXX_NOEXCEPT
          .          .          .                    .          .          .            .          .          .                 {
          4 ( 0.00%) 2 ( 0.07%) 1 ( 0.04%)           4 ( 0.00%) 0          0            0          0          0           	std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
          .          .          .                    .          .          .            .          .          .           		      _M_get_Tp_allocator());
          .          .          .                    .          .          .            .          .          .           	_GLIBCXX_ASAN_ANNOTATE_BEFORE_DEALLOC;
          .          .          .                    .          .          .            .          .          .                 }
          .          .          .                    .          .          .            .          .          .           
          .          .          .                    .          .          .            .          .          .                 /**
          .          .          .                    .          .          .            .          .          .                  *  @brief  %Vector assignment operator.
          .          .          .                    .          .          .            .          .          .                  *  @param  __x  A %vector of identical element and allocator types.
          .          .          .                    .          .          .            .          .          .                  *
-- line 738 ----------------------------------------
-- line 980 ----------------------------------------
          .          .          .                    .          .          .            .          .          .                 { return const_reverse_iterator(begin()); }
          .          .          .                    .          .          .            .          .          .           #endif
          .          .          .                    .          .          .            .          .          .           
          .          .          .                    .          .          .            .          .          .                 // [23.2.4.2] capacity
          .          .          .                    .          .          .            .          .          .                 /**  Returns the number of elements in the %vector.  */
          .          .          .                    .          .          .            .          .          .                 _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR
          .          .          .                    .          .          .            .          .          .                 size_type
          .          .          .                    .          .          .            .          .          .                 size() const _GLIBCXX_NOEXCEPT
         13 ( 0.00%) 1 ( 0.04%) 1 ( 0.04%)           6 ( 0.00%) 0          0            2 ( 0.00%) 0          0                 { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
          .          .          .                    .          .          .            .          .          .           
          .          .          .                    .          .          .            .          .          .                 /**  Returns the size() of the largest possible %vector.  */
          .          .          .                    .          .          .            .          .          .                 _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR
          .          .          .                    .          .          .            .          .          .                 size_type
          .          .          .                    .          .          .            .          .          .                 max_size() const _GLIBCXX_NOEXCEPT
          .          .          .                    .          .          .            .          .          .                 { return _S_max_size(_M_get_Tp_allocator()); }
          .          .          .                    .          .          .            .          .          .           
          .          .          .                    .          .          .            .          .          .           #if __cplusplus >= 201103L
-- line 996 ----------------------------------------
-- line 1023 ----------------------------------------
          .          .          .                    .          .          .            .          .          .                  *  %vector's current size the %vector is truncated, otherwise
          .          .          .                    .          .          .            .          .          .                  *  the %vector is extended and new elements are populated with
          .          .          .                    .          .          .            .          .          .                  *  given data.
          .          .          .                    .          .          .            .          .          .                  */
          .          .          .                    .          .          .            .          .          .                 _GLIBCXX20_CONSTEXPR
          .          .          .                    .          .          .            .          .          .                 void
          .          .          .                    .          .          .            .          .          .                 resize(size_type __new_size, const value_type& __x)
          .          .          .                    .          .          .            .          .          .                 {
        812 ( 0.00%) 0          0                    0          0          0            0          0          0           	if (__new_size > size())
      2,842 ( 0.00%) 1 ( 0.04%) 1 ( 0.04%)         812 ( 0.00%) 0          0          812 ( 0.00%) 0          0           	  _M_fill_insert(end(), __new_size - size(), __x);
          .          .          .                    .          .          .            .          .          .           	else if (__new_size < size())
          .          .          .                    .          .          .            .          .          .           	  _M_erase_at_end(this->_M_impl._M_start + __new_size);
          .          .          .                    .          .          .            .          .          .                 }
          .          .          .                    .          .          .            .          .          .           #else
          .          .          .                    .          .          .            .          .          .                 /**
          .          .          .                    .          .          .            .          .          .                  *  @brief  Resizes the %vector to the specified number of elements.
          .          .          .                    .          .          .            .          .          .                  *  @param  __new_size  Number of elements the %vector should contain.
          .          .          .                    .          .          .            .          .          .                  *  @param  __x  Data with which new elements should be populated.
-- line 1040 ----------------------------------------
-- line 1067 ----------------------------------------
          .          .          .                    .          .          .            .          .          .                 /**
          .          .          .                    .          .          .            .          .          .                  *  Returns the total number of elements that the %vector can
          .          .          .                    .          .          .            .          .          .                  *  hold before needing to allocate more memory.
          .          .          .                    .          .          .            .          .          .                  */
          .          .          .                    .          .          .            .          .          .                 _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR
          .          .          .                    .          .          .            .          .          .                 size_type
          .          .          .                    .          .          .            .          .          .                 capacity() const _GLIBCXX_NOEXCEPT
          .          .          .                    .          .          .            .          .          .                 { return size_type(this->_M_impl._M_end_of_storage
          3 ( 0.00%) 0          0                    2 ( 0.00%) 0          0            0          0          0           			 - this->_M_impl._M_start); }
          .          .          .                    .          .          .            .          .          .           
          .          .          .                    .          .          .            .          .          .                 /**
          .          .          .                    .          .          .            .          .          .                  *  Returns true if the %vector is empty.  (Thus begin() would
          .          .          .                    .          .          .            .          .          .                  *  equal end().)
          .          .          .                    .          .          .            .          .          .                  */
          .          .          .                    .          .          .            .          .          .                 _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR
          .          .          .                    .          .          .            .          .          .                 bool
          .          .          .                    .          .          .            .          .          .                 empty() const _GLIBCXX_NOEXCEPT
-- line 1083 ----------------------------------------
-- line 1116 ----------------------------------------
          .          .          .                    .          .          .            .          .          .                  *  out_of_range lookups are not defined. (For checked lookups
          .          .          .                    .          .          .            .          .          .                  *  see at().)
          .          .          .                    .          .          .            .          .          .                  */
          .          .          .                    .          .          .            .          .          .                 _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR
          .          .          .                    .          .          .            .          .          .                 reference
          .          .          .                    .          .          .            .          .          .                 operator[](size_type __n) _GLIBCXX_NOEXCEPT
          .          .          .                    .          .          .            .          .          .                 {
          .          .          .                    .          .          .            .          .          .           	__glibcxx_requires_subscript(__n);
649,602,048 ( 2.97%) 0          0          324,801,227 ( 9.05%) 0          0            1 ( 0.00%) 0          0           	return *(this->_M_impl._M_start + __n);
          .          .          .                    .          .          .            .          .          .                 }
          .          .          .                    .          .          .            .          .          .           
          .          .          .                    .          .          .            .          .          .                 /**
          .          .          .                    .          .          .            .          .          .                  *  @brief  Subscript access to the data contained in the %vector.
          .          .          .                    .          .          .            .          .          .                  *  @param __n The index of the element for which data should be
          .          .          .                    .          .          .            .          .          .                  *  accessed.
          .          .          .                    .          .          .            .          .          .                  *  @return  Read-only (constant) reference to data.
          .          .          .                    .          .          .            .          .          .                  *
-- line 1132 ----------------------------------------
-- line 1593 ----------------------------------------
          .          .          .                    .          .          .            .          .          .                  *  Erases all the elements.  Note that this function only erases the
          .          .          .                    .          .          .            .          .          .                  *  elements, and that if the elements themselves are pointers, the
          .          .          .                    .          .          .            .          .          .                  *  pointed-to memory is not touched in any way.  Managing the pointer is
          .          .          .                    .          .          .            .          .          .                  *  the user's responsibility.
          .          .          .                    .          .          .            .          .          .                  */
          .          .          .                    .          .          .            .          .          .                 _GLIBCXX20_CONSTEXPR
          .          .          .                    .          .          .            .          .          .                 void
          .          .          .                    .          .          .            .          .          .                 clear() _GLIBCXX_NOEXCEPT
        406 ( 0.00%) 0          0                  406 ( 0.00%) 0          0            0          0          0                 { _M_erase_at_end(this->_M_impl._M_start); }
          .          .          .                    .          .          .            .          .          .           
          .          .          .                    .          .          .            .          .          .               protected:
          .          .          .                    .          .          .            .          .          .                 /**
          .          .          .                    .          .          .            .          .          .                  *  Memory expansion handler.  Uses the member allocation function to
          .          .          .                    .          .          .            .          .          .                  *  obtain @a n bytes of memory, and then copies [first,last) into it.
          .          .          .                    .          .          .            .          .          .                  */
          .          .          .                    .          .          .            .          .          .                 template<typename _ForwardIterator>
          .          .          .                    .          .          .            .          .          .           	_GLIBCXX20_CONSTEXPR
-- line 1609 ----------------------------------------
-- line 1693 ----------------------------------------
          .          .          .                    .          .          .            .          .          .           	}
          .          .          .                    .          .          .            .          .          .           
          .          .          .                    .          .          .            .          .          .                 // Called by the first initialize_dispatch above and by the
          .          .          .                    .          .          .            .          .          .                 // vector(n,value,a) constructor.
          .          .          .                    .          .          .            .          .          .                 _GLIBCXX20_CONSTEXPR
          .          .          .                    .          .          .            .          .          .                 void
          .          .          .                    .          .          .            .          .          .                 _M_fill_initialize(size_type __n, const value_type& __value)
          .          .          .                    .          .          .            .          .          .                 {
          4 ( 0.00%) 0          0                    0          0          0            4 ( 0.00%) 0          0           	this->_M_impl._M_finish =
          .          .          .                    .          .          .            .          .          .           	  std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value,
          .          .          .                    .          .          .            .          .          .           					_M_get_Tp_allocator());
          .          .          .                    .          .          .            .          .          .                 }
          .          .          .                    .          .          .            .          .          .           
          .          .          .                    .          .          .            .          .          .           #if __cplusplus >= 201103L
          .          .          .                    .          .          .            .          .          .                 // Called by the vector(n) constructor.
          .          .          .                    .          .          .            .          .          .                 _GLIBCXX20_CONSTEXPR
          .          .          .                    .          .          .            .          .          .                 void
-- line 1709 ----------------------------------------
-- line 1896 ----------------------------------------
          .          .          .                    .          .          .            .          .          .           	const size_type __len = size() + (std::max)(size(), __n);
          .          .          .                    .          .          .            .          .          .           	return (__len < size() || __len > max_size()) ? max_size() : __len;
          .          .          .                    .          .          .            .          .          .                 }
          .          .          .                    .          .          .            .          .          .           
          .          .          .                    .          .          .            .          .          .                 // Called by constructors to check initial size.
          .          .          .                    .          .          .            .          .          .                 static _GLIBCXX20_CONSTEXPR size_type
          .          .          .                    .          .          .            .          .          .                 _S_check_init_len(size_type __n, const allocator_type& __a)
          .          .          .                    .          .          .            .          .          .                 {
         12 ( 0.00%) 1 ( 0.04%) 1 ( 0.04%)           0          0          0            0          0          0           	if (__n > _S_max_size(_Tp_alloc_type(__a)))
          .          .          .                    .          .          .            .          .          .           	  __throw_length_error(
          .          .          .                    .          .          .            .          .          .           	      __N("cannot create std::vector larger than max_size()"));
          .          .          .                    .          .          .            .          .          .           	return __n;
          .          .          .                    .          .          .            .          .          .                 }
          .          .          .                    .          .          .            .          .          .           
          .          .          .                    .          .          .            .          .          .                 static _GLIBCXX20_CONSTEXPR size_type
          .          .          .                    .          .          .            .          .          .                 _S_max_size(const _Tp_alloc_type& __a) _GLIBCXX_NOEXCEPT
          .          .          .                    .          .          .            .          .          .                 {
-- line 1912 ----------------------------------------
-- line 1922 ----------------------------------------
          .          .          .                    .          .          .            .          .          .                 // Internal erase functions follow.
          .          .          .                    .          .          .            .          .          .           
          .          .          .                    .          .          .            .          .          .                 // Called by erase(q1,q2), clear(), resize(), _M_fill_assign,
          .          .          .                    .          .          .            .          .          .                 // _M_assign_aux.
          .          .          .                    .          .          .            .          .          .                 _GLIBCXX20_CONSTEXPR
          .          .          .                    .          .          .            .          .          .                 void
          .          .          .                    .          .          .            .          .          .                 _M_erase_at_end(pointer __pos) _GLIBCXX_NOEXCEPT
          .          .          .                    .          .          .            .          .          .                 {
        814 ( 0.00%) 0          0                  406 ( 0.00%) 0          0            0          0          0           	if (size_type __n = this->_M_impl._M_finish - __pos)
          .          .          .                    .          .          .            .          .          .           	  {
          .          .          .                    .          .          .            .          .          .           	    std::_Destroy(__pos, this->_M_impl._M_finish,
          .          .          .                    .          .          .            .          .          .           			  _M_get_Tp_allocator());
        406 ( 0.00%) 1 ( 0.04%) 1 ( 0.04%)           0          0          0          406 ( 0.00%) 0          0           	    this->_M_impl._M_finish = __pos;
          .          .          .                    .          .          .            .          .          .           	    _GLIBCXX_ASAN_ANNOTATE_SHRINK(__n);
          .          .          .                    .          .          .            .          .          .           	  }
          .          .          .                    .          .          .            .          .          .                 }
          .          .          .                    .          .          .            .          .          .           
          .          .          .                    .          .          .            .          .          .                 _GLIBCXX20_CONSTEXPR
          .          .          .                    .          .          .            .          .          .                 iterator
          .          .          .                    .          .          .            .          .          .                 _M_erase(iterator __position);
          .          .          .                    .          .          .            .          .          .           
-- line 1942 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/jovyan/Proyecto-intermedio-entropia/code/random_movement.cpp
--------------------------------------------------------------------------------
Ir                     I1mr       ILmr       Dr                   D1mr       DLmr       Dw                   D1mw       DLmw       

            .          .          .                    .          .          .                    .          .          .           #include "random_movement.hpp"
            .          .          .                    .          .          .                    .          .          .           
    6,496,000 ( 0.03%) 1 ( 0.04%) 1 ( 0.04%)           0          0          0            5,684,000 ( 0.58%) 0          0           void random_movement(int &dim, int &n_molecules, int &lattice_size, std::vector<double> &molecules, std::mt19937 &gen, std::uniform_int_distribution<int> &direction_distribution){
            .          .          .                    .          .          .                    .          .          .           
            .          .          .                    .          .          .                    .          .          .               // The constant movement passage of the simulation is defined
            .          .          .                    .          .          .                    .          .          .               double step_size = 0.005;
            .          .          .                    .          .          .                    .          .          .           
            .          .          .                    .          .          .                    .          .          .               // Definition of constants for particle movement
            .          .          .                    .          .          .                    .          .          .               int pos_x = 0, pos_y = 1;
            .          .          .                    .          .          .                    .          .          .               int direction = 0;
    3,248,000 ( 0.01%) 0          0            1,624,000 ( 0.05%) 0          0              812,000 ( 0.08%) 0          0               double limit = lattice_size/2.0; // Limit for a centered coordinate system
    1,624,000 ( 0.01%) 0          0              812,000 ( 0.02%) 1 ( 0.01%) 1 ( 0.01%)     812,000 ( 0.08%) 0          0               double m_limit = -1.0*limit;
            .          .          .                    .          .          .                    .          .          .           
            .          .          .                    .          .          .                    .          .          .               // For contact with the wall or position outside the box, the movement in that direction is reflected twice
            .          .          .                    .          .          .                    .          .          .               double step_backward = 2.0*step_size; 
            .          .          .                    .          .          .                    .          .          .           
  978,460,000 ( 4.47%) 1 ( 0.04%) 1 ( 0.04%)   1,624,000 ( 0.05%) 0          0                    0          0          0               for (int i = 0; i < n_molecules; i++){
            .          .          .                    .          .          .                    .          .          .                   direction = direction_distribution(gen);
1,380,372,319 ( 6.31%) 2 ( 0.07%) 2 ( 0.08%)           0          0          0                    0          0          0                   switch (direction) {
            .          .          .                    .          .          .                    .          .          .                       case 0: // Up
  406,048,340 ( 1.85%) 0          0          162,419,336 ( 4.53%) 0          0                    0          0          0                           molecules[i*dim + pos_y] += step_size;
            .          .          .                    .          .          .                    .          .          .                           if (molecules[i*dim + pos_y] >= limit) molecules[i*dim + pos_y] -= step_backward;
            .          .          .                    .          .          .                    .          .          .                           break;
            .          .          .                    .          .          .                    .          .          .           
            .          .          .                    .          .          .                    .          .          .                       case 1: // Down
  568,255,135 ( 2.60%) 0          0          324,717,220 ( 9.05%) 0          0                    0          0          0                           molecules[i*dim + pos_y] -= step_size;
  243,537,915 ( 1.11%) 0          0           81,179,305 ( 2.26%) 0          0                    0          0          0                           if (molecules[i*dim + pos_y] <= m_limit) molecules[i*dim + pos_y] += step_backward;
            .          .          .                    .          .          .                    .          .          .                           break;
            .          .          .                    .          .          .                    .          .          .           
            .          .          .                    .          .          .                    .          .          .                       case 2: // Left
  487,255,362 ( 2.23%) 1 ( 0.04%) 1 ( 0.04%) 324,836,908 ( 9.05%) 0          0                    0          0          0                           molecules[i*dim + pos_x] -= step_size;
  324,911,693 ( 1.48%) 1 ( 0.04%) 1 ( 0.04%)  81,239,806 ( 2.26%) 0          0               30,579 ( 0.00%) 0          0                           if (molecules[i*dim + pos_x] <= m_limit) molecules[i*dim + pos_x] += step_backward;
            .          .          .                    .          .          .                    .          .          .                           break;
            .          .          .                    .          .          .                    .          .          .           
            .          .          .                    .          .          .                    .          .          .                       case 3: // Right
  730,839,804 ( 3.34%) 0          0          487,226,536 (13.58%) 0          0                    0          0          0                           molecules[i*dim + pos_x] += step_size;
  974,394,513 ( 4.45%) 0          0          162,444,203 ( 4.53%) 0          0          324,769,421 (32.96%) 0          0                           if (molecules[i*dim + pos_x] >= limit) molecules[i*dim + pos_x] -= step_backward;
            .          .          .                    .          .          .                    .          .          .                           break;
            .          .          .                    .          .          .                    .          .          .                   }
            .          .          .                    .          .          .                    .          .          .               }   
    6,496,002 ( 0.03%) 0          0            5,684,001 ( 0.16%) 0          0                    1 ( 0.00%) 0          0           }
--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/12/bits/random.tcc
--------------------------------------------------------------------------------
Ir                     I1mr       ILmr       Dr                   D1mr       DLmr       Dw                   D1mw        DLmw       

-- line 322 ----------------------------------------
            .          .          .                    .          .          .                    .           .          .           	   _UIntType __a, size_t __u, _UIntType __d, size_t __s,
            .          .          .                    .          .          .                    .           .          .           	   _UIntType __b, size_t __t, _UIntType __c, size_t __l,
            .          .          .                    .          .          .                    .           .          .           	   _UIntType __f>
            .          .          .                    .          .          .                    .           .          .               void
            .          .          .                    .          .          .                    .           .          .               mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
            .          .          .                    .          .          .                    .           .          .           			    __s, __b, __t, __c, __l, __f>::
            .          .          .                    .          .          .                    .           .          .               seed(result_type __sd)
            .          .          .                    .          .          .                    .           .          .               {
            5 ( 0.00%) 0          0                    0          0          0                    5 ( 0.00%)  0          0                 _M_x[0] = __detail::__mod<_UIntType,
            .          .          .                    .          .          .                    .           .          .           	__detail::_Shift<_UIntType, __w>::__value>(__sd);
            .          .          .                    .          .          .                    .           .          .           
       10,172 ( 0.00%) 2 ( 0.07%) 2 ( 0.08%)           0          0          0                    0           0          0                 for (size_t __i = 1; __i < state_size; ++__i)
            .          .          .                    .          .          .                    .           .          .           	{
            .          .          .                    .          .          .                    .           .          .           	  _UIntType __x = _M_x[__i - 1];
        9,345 ( 0.00%) 0          0                    0          0          0                    0           0          0           	  __x ^= __x >> (__w - 2);
        3,115 ( 0.00%) 0          0                    0          0          0                    0           0          0           	  __x *= __f;
            .          .          .                    .          .          .                    .           .          .           	  __x += __detail::__mod<_UIntType, __n>(__i);
        3,115 ( 0.00%) 0          0                    0          0          0                3,115 ( 0.00%) 69 ( 2.87%) 0           	  _M_x[__i] = __detail::__mod<_UIntType,
            .          .          .                    .          .          .                    .           .          .           	    __detail::_Shift<_UIntType, __w>::__value>(__x);
            .          .          .                    .          .          .                    .           .          .           	}
            5 ( 0.00%) 1 ( 0.04%) 1 ( 0.04%)           0          0          0                    5 ( 0.00%)  0          0                 _M_p = state_size;
            .          .          .                    .          .          .                    .           .          .               }
            .          .          .                    .          .          .                    .           .          .           
            .          .          .                    .          .          .                    .           .          .             template<typename _UIntType,
            .          .          .                    .          .          .                    .           .          .           	   size_t __w, size_t __n, size_t __m, size_t __r,
            .          .          .                    .          .          .                    .           .          .           	   _UIntType __a, size_t __u, _UIntType __d, size_t __s,
            .          .          .                    .          .          .                    .           .          .           	   _UIntType __b, size_t __t, _UIntType __c, size_t __l,
            .          .          .                    .          .          .                    .           .          .           	   _UIntType __f>
            .          .          .                    .          .          .                    .           .          .               template<typename _Sseq>
-- line 350 ----------------------------------------
-- line 389 ----------------------------------------
            .          .          .                    .          .          .                    .           .          .                 }
            .          .          .                    .          .          .                    .           .          .           
            .          .          .                    .          .          .                    .           .          .             template<typename _UIntType, size_t __w,
            .          .          .                    .          .          .                    .           .          .           	   size_t __n, size_t __m, size_t __r,
            .          .          .                    .          .          .                    .           .          .           	   _UIntType __a, size_t __u, _UIntType __d, size_t __s,
            .          .          .                    .          .          .                    .           .          .           	   _UIntType __b, size_t __t, _UIntType __c, size_t __l,
            .          .          .                    .          .          .                    .           .          .           	   _UIntType __f>
            .          .          .                    .          .          .                    .           .          .               void
    2,082,064 ( 0.01%) 1 ( 0.04%) 1 ( 0.04%)     520,516 ( 0.01%) 0          0                    0           0          0               mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
            .          .          .                    .          .          .                    .           .          .           			    __s, __b, __t, __c, __l, __f>::
            .          .          .                    .          .          .                    .           .          .               _M_gen_rand(void)
            .          .          .                    .          .          .                    .           .          .               {
            .          .          .                    .          .          .                    .           .          .                 const _UIntType __upper_mask = (~_UIntType()) << __r;
            .          .          .                    .          .          .                    .           .          .                 const _UIntType __lower_mask = ~__upper_mask;
            .          .          .                    .          .          .                    .           .          .           
  355,512,428 ( 1.62%) 0          0              520,516 ( 0.01%) 0          0                    0           0          0                 for (size_t __k = 0; __k < (__n - __m); ++__k)
            .          .          .                    .          .          .                    .           .          .                   {
  354,471,396 ( 1.62%) 0          0                    0          0          0                    0           0          0           	  _UIntType __y = ((_M_x[__k] & __upper_mask)
  354,471,396 ( 1.62%) 1 ( 0.04%) 1 ( 0.04%) 118,157,132 ( 3.29%) 0          0                    0           0          0           			   | (_M_x[__k + 1] & __lower_mask));
  472,628,528 ( 2.16%) 0          0          118,157,132 ( 3.29%) 0          0          118,157,132 (11.99%)  0          0           	  _M_x[__k] = (_M_x[__k + __m] ^ (__y >> 1)
  296,958,679 ( 1.36%) 0          0                    0          0          0                    0           0          0           		       ^ ((__y & 0x01) ? __a : 0));
            .          .          .                    .          .          .                    .           .          .                   }
            .          .          .                    .          .          .                    .           .          .           
  618,373,008 ( 2.82%) 0          0                    0          0          0                    0           0          0                 for (size_t __k = (__n - __m); __k < (__n - 1); ++__k)
            .          .          .                    .          .          .                    .           .          .           	{
  618,373,008 ( 2.82%) 1 ( 0.04%) 1 ( 0.04%)           0          0          0                    0           0          0           	  _UIntType __y = ((_M_x[__k] & __upper_mask)
  618,373,008 ( 2.82%) 0          0          206,124,336 ( 5.74%) 0          0                    0           0          0           			   | (_M_x[__k + 1] & __lower_mask));
  824,497,344 ( 3.77%) 0          0          206,124,336 ( 5.74%) 0          0          206,124,336 (20.92%)  0          0           	  _M_x[__k] = (_M_x[__k + (__m - __n)] ^ (__y >> 1)
  516,330,544 ( 2.36%) 0          0                    0          0          0                    0           0          0           		       ^ ((__y & 0x01) ? __a : 0));
            .          .          .                    .          .          .                    .           .          .           	}
            .          .          .                    .          .          .                    .           .          .           
    1,561,548 ( 0.01%) 1 ( 0.04%) 1 ( 0.04%)     520,516 ( 0.01%) 0          0                    0           0          0                 _UIntType __y = ((_M_x[__n - 1] & __upper_mask)
    1,041,032 ( 0.00%) 0          0              520,516 ( 0.01%) 0          0                    0           0          0           		       | (_M_x[0] & __lower_mask));
    2,082,064 ( 0.01%) 0          0              520,516 ( 0.01%) 0          0              520,516 ( 0.05%)  0          0                 _M_x[__n - 1] = (_M_x[__m - 1] ^ (__y >> 1)
    1,562,506 ( 0.01%) 0          0                    0          0          0                    0           0          0           		       ^ ((__y & 0x01) ? __a : 0));
      520,516 ( 0.00%) 0          0                    0          0          0              520,516 ( 0.05%)  0          0                 _M_p = 0;
      520,516 ( 0.00%) 0          0              520,516 ( 0.01%) 0          0                    0           0          0               }
            .          .          .                    .          .          .                    .           .          .           
            .          .          .                    .          .          .                    .           .          .             template<typename _UIntType, size_t __w,
            .          .          .                    .          .          .                    .           .          .           	   size_t __n, size_t __m, size_t __r,
            .          .          .                    .          .          .                    .           .          .           	   _UIntType __a, size_t __u, _UIntType __d, size_t __s,
            .          .          .                    .          .          .                    .           .          .           	   _UIntType __b, size_t __t, _UIntType __c, size_t __l,
            .          .          .                    .          .          .                    .           .          .           	   _UIntType __f>
            .          .          .                    .          .          .                    .           .          .               void
            .          .          .                    .          .          .                    .           .          .               mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
-- line 433 ----------------------------------------
-- line 450 ----------------------------------------
            .          .          .                    .          .          .                    .           .          .               typename
            .          .          .                    .          .          .                    .           .          .               mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
            .          .          .                    .          .          .                    .           .          .           			    __s, __b, __t, __c, __l, __f>::result_type
            .          .          .                    .          .          .                    .           .          .               mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
            .          .          .                    .          .          .                    .           .          .           			    __s, __b, __t, __c, __l, __f>::
            .          .          .                    .          .          .                    .           .          .               operator()()
            .          .          .                    .          .          .                    .           .          .               {
            .          .          .                    .          .          .                    .           .          .                 // Reload the vector - cost is O(n) amortized over n calls.
  974,400,000 ( 4.45%) 1 ( 0.04%) 1 ( 0.04%) 324,800,000 ( 9.05%) 0          0                    0           0          0                 if (_M_p >= state_size)
    1,041,032 ( 0.00%) 1 ( 0.04%) 1 ( 0.04%)           0          0          0              520,516 ( 0.05%)  0          0           	_M_gen_rand();
            .          .          .                    .          .          .                    .           .          .           
            .          .          .                    .          .          .                    .           .          .                 // Calculate o(x(i)).
  975,441,032 ( 4.46%) 1 ( 0.04%) 1 ( 0.04%) 325,320,516 ( 9.07%) 0          0          324,800,000 (32.96%)  0          0                 result_type __z = _M_x[_M_p++];
1,299,200,000 ( 5.93%) 0          0                    0          0          0                    0           0          0                 __z ^= (__z >> __u) & __d;
1,299,200,000 ( 5.93%) 0          0                    0          0          0                    0           0          0                 __z ^= (__z << __s) & __b;
1,299,200,000 ( 5.93%) 0          0                    0          0          0                    0           0          0                 __z ^= (__z << __t) & __c;
  974,400,000 ( 4.45%) 0          0                    0          0          0                    0           0          0                 __z ^= (__z >> __l);
            .          .          .                    .          .          .                    .           .          .           
            .          .          .                    .          .          .                    .           .          .                 return __z;
            .          .          .                    .          .          .                    .           .          .               }
            .          .          .                    .          .          .                    .           .          .           
            .          .          .                    .          .          .                    .           .          .             template<typename _UIntType, size_t __w,
            .          .          .                    .          .          .                    .           .          .           	   size_t __n, size_t __m, size_t __r,
            .          .          .                    .          .          .                    .           .          .           	   _UIntType __a, size_t __u, _UIntType __d, size_t __s,
            .          .          .                    .          .          .                    .           .          .           	   _UIntType __b, size_t __t, _UIntType __c, size_t __l,
-- line 474 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/12/bits/uniform_int_dist.h
--------------------------------------------------------------------------------
Ir                   I1mr       ILmr       Dr                   D1mr       DLmr       Dw               D1mw       DLmw       

-- line 87 ----------------------------------------
          .          .          .                    .          .          .                .          .          .                 {
          .          .          .                    .          .          .                .          .          .           	typedef uniform_int_distribution<_IntType> distribution_type;
          .          .          .                    .          .          .                .          .          .           
          .          .          .                    .          .          .                .          .          .           	param_type() : param_type(0) { }
          .          .          .                    .          .          .                .          .          .           
          .          .          .                    .          .          .                .          .          .           	explicit
          .          .          .                    .          .          .                .          .          .           	param_type(_IntType __a,
          .          .          .                    .          .          .                .          .          .           		   _IntType __b = __gnu_cxx::__int_traits<_IntType>::__max)
         10 ( 0.00%) 0          0                    5 ( 0.00%) 0          0                5 ( 0.00%) 0          0           	: _M_a(__a), _M_b(__b)
          .          .          .                    .          .          .                .          .          .           	{
          .          .          .                    .          .          .                .          .          .           	  __glibcxx_assert(_M_a <= _M_b);
          .          .          .                    .          .          .                .          .          .           	}
          .          .          .                    .          .          .                .          .          .           
          .          .          .                    .          .          .                .          .          .           	result_type
          .          .          .                    .          .          .                .          .          .           	a() const
          .          .          .                    .          .          .                .          .          .           	{ return _M_a; }
          .          .          .                    .          .          .                .          .          .           
-- line 103 ----------------------------------------
-- line 250 ----------------------------------------
          .          .          .                    .          .          .                .          .          .           	  static_assert(!_Up_traits::__is_signed, "U must be unsigned");
          .          .          .                    .          .          .                .          .          .           	  static_assert(!_Wp_traits::__is_signed, "W must be unsigned");
          .          .          .                    .          .          .                .          .          .           	  static_assert(_Wp_traits::__digits == (2 * _Up_traits::__digits),
          .          .          .                    .          .          .                .          .          .           			"W must be twice as wide as U");
          .          .          .                    .          .          .                .          .          .           
          .          .          .                    .          .          .                .          .          .           	  // reference: Fast Random Integer Generation in an Interval
          .          .          .                    .          .          .                .          .          .           	  // ACM Transactions on Modeling and Computer Simulation 29 (1), 2019
          .          .          .                    .          .          .                .          .          .           	  // https://arxiv.org/abs/1805.10941
324,800,000 ( 1.48%) 0          0                    0          0          0                0          0          0           	  _Wp __product = _Wp(__g()) * _Wp(__range);
          .          .          .                    .          .          .                .          .          .           	  _Up __low = _Up(__product);
649,600,000 ( 2.97%) 1 ( 0.04%) 1 ( 0.04%)           0          0          0                0          0          0           	  if (__low < __range)
          .          .          .                    .          .          .                .          .          .           	    {
          .          .          .                    .          .          .                .          .          .           	      _Up __threshold = -__range % __range;
          .          .          .                    .          .          .                .          .          .           	      while (__low < __threshold)
          .          .          .                    .          .          .                .          .          .           		{
          .          .          .                    .          .          .                .          .          .           		  __product = _Wp(__g()) * _Wp(__range);
          .          .          .                    .          .          .                .          .          .           		  __low = _Up(__product);
          .          .          .                    .          .          .                .          .          .           		}
          .          .          .                    .          .          .                .          .          .           	    }
649,600,000 ( 2.97%) 0          0                    0          0          0                0          0          0           	  return __product >> _Up_traits::__digits;
          .          .          .                    .          .          .                .          .          .           	}
          .          .          .                    .          .          .                .          .          .               };
          .          .          .                    .          .          .                .          .          .           
          .          .          .                    .          .          .                .          .          .             template<typename _IntType>
          .          .          .                    .          .          .                .          .          .               template<typename _UniformRandomBitGenerator>
          .          .          .                    .          .          .                .          .          .                 typename uniform_int_distribution<_IntType>::result_type
          .          .          .                    .          .          .                .          .          .                 uniform_int_distribution<_IntType>::
          .          .          .                    .          .          .                .          .          .                 operator()(_UniformRandomBitGenerator& __urng,
-- line 277 ----------------------------------------
-- line 282 ----------------------------------------
          .          .          .                    .          .          .                .          .          .           	typedef typename common_type<_Gresult_type, __utype>::type __uctype;
          .          .          .                    .          .          .                .          .          .           
          .          .          .                    .          .          .                .          .          .           	constexpr __uctype __urngmin = _UniformRandomBitGenerator::min();
          .          .          .                    .          .          .                .          .          .           	constexpr __uctype __urngmax = _UniformRandomBitGenerator::max();
          .          .          .                    .          .          .                .          .          .           	static_assert( __urngmin < __urngmax,
          .          .          .                    .          .          .                .          .          .           	    "Uniform random bit generator must define min() < max()");
          .          .          .                    .          .          .                .          .          .           	constexpr __uctype __urngrange = __urngmax - __urngmin;
          .          .          .                    .          .          .                .          .          .           
  1,624,000 ( 0.01%) 0          0                    0          0          0          812,000 ( 0.08%) 0          0           	const __uctype __urange
  2,436,000 ( 0.01%) 0          0              812,000 ( 0.02%) 0          0                0          0          0           	  = __uctype(__param.b()) - __uctype(__param.a());
          .          .          .                    .          .          .                .          .          .           
          .          .          .                    .          .          .                .          .          .           	__uctype __ret;
974,400,000 ( 4.45%) 0          0                    0          0          0                0          0          0           	if (__urngrange > __urange)
          .          .          .                    .          .          .                .          .          .           	  {
          .          .          .                    .          .          .                .          .          .           	    // downscaling
          .          .          .                    .          .          .                .          .          .           
    812,000 ( 0.00%) 0          0                    0          0          0                0          0          0           	    const __uctype __uerange = __urange + 1; // __urange can be zero
          .          .          .                    .          .          .                .          .          .           
          .          .          .                    .          .          .                .          .          .           #if defined __UINT64_TYPE__ && defined __UINT32_TYPE__
          .          .          .                    .          .          .                .          .          .           #if __SIZEOF_INT128__
          .          .          .                    .          .          .                .          .          .           	    if _GLIBCXX17_CONSTEXPR (__urngrange == __UINT64_MAX__)
          .          .          .                    .          .          .                .          .          .           	      {
          .          .          .                    .          .          .                .          .          .           		// __urng produces values that use exactly 64-bits,
          .          .          .                    .          .          .                .          .          .           		// so use 128-bit integers to downscale to desired range.
          .          .          .                    .          .          .                .          .          .           		__UINT64_TYPE__ __u64erange = __uerange;
-- line 306 ----------------------------------------
-- line 308 ----------------------------------------
          .          .          .                    .          .          .                .          .          .           							       __u64erange);
          .          .          .                    .          .          .                .          .          .           	      }
          .          .          .                    .          .          .                .          .          .           	    else
          .          .          .                    .          .          .                .          .          .           #endif
          .          .          .                    .          .          .                .          .          .           	    if _GLIBCXX17_CONSTEXPR (__urngrange == __UINT32_MAX__)
          .          .          .                    .          .          .                .          .          .           	      {
          .          .          .                    .          .          .                .          .          .           		// __urng produces values that use exactly 32-bits,
          .          .          .                    .          .          .                .          .          .           		// so use 64-bit integers to downscale to desired range.
  1,624,000 ( 0.01%) 0          0                    0          0          0          812,000 ( 0.08%) 0          0           		__UINT32_TYPE__ __u32erange = __uerange;
          .          .          .                    .          .          .                .          .          .           		__ret = _S_nd<__UINT64_TYPE__>(__urng, __u32erange);
          .          .          .                    .          .          .                .          .          .           	      }
          .          .          .                    .          .          .                .          .          .           	    else
          .          .          .                    .          .          .                .          .          .           #endif
          .          .          .                    .          .          .                .          .          .           	      {
          .          .          .                    .          .          .                .          .          .           		// fallback case (2 divisions)
          .          .          .                    .          .          .                .          .          .           		const __uctype __scaling = __urngrange / __uerange;
          .          .          .                    .          .          .                .          .          .           		const __uctype __past = __uerange * __scaling;
-- line 324 ----------------------------------------
-- line 353 ----------------------------------------
          .          .          .                    .          .          .                .          .          .           			 (__urng, param_type(0, __urange / __uerngrange)));
          .          .          .                    .          .          .                .          .          .           		__ret = __tmp + (__uctype(__urng()) - __urngmin);
          .          .          .                    .          .          .                .          .          .           	      }
          .          .          .                    .          .          .                .          .          .           	    while (__ret > __urange || __ret < __tmp);
          .          .          .                    .          .          .                .          .          .           	  }
          .          .          .                    .          .          .                .          .          .           	else
          .          .          .                    .          .          .                .          .          .           	  __ret = __uctype(__urng()) - __urngmin;
          .          .          .                    .          .          .                .          .          .           
649,600,000 ( 2.97%) 1 ( 0.04%) 1 ( 0.04%) 324,800,000 ( 9.05%) 0          0                0          0          0           	return __ret + __param.a();
          .          .          .                    .          .          .                .          .          .                 }
          .          .          .                    .          .          .                .          .          .           
          .          .          .                    .          .          .                .          .          .           
          .          .          .                    .          .          .                .          .          .             template<typename _IntType>
          .          .          .                    .          .          .                .          .          .               template<typename _ForwardIterator,
          .          .          .                    .          .          .                .          .          .           	     typename _UniformRandomBitGenerator>
          .          .          .                    .          .          .                .          .          .                 void
          .          .          .                    .          .          .                .          .          .                 uniform_int_distribution<_IntType>::
-- line 369 ----------------------------------------

--------------------------------------------------------------------------------
Ir                      I1mr        ILmr        Dr                     D1mr       DLmr       Dw                   D1mw        DLmw       
--------------------------------------------------------------------------------
21,878,309,942 (99.93%) 25 ( 0.88%) 24 ( 1.01%) 3,586,028,747 (99.92%) 1 ( 0.01%) 1 ( 0.01%) 984,379,397 (99.89%) 70 ( 2.91%) 0           events annotated

