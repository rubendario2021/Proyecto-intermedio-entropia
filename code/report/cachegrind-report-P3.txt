--------------------------------------------------------------------------------
I1 cache:         32768 B, 64 B, 8-way associative
D1 cache:         49152 B, 64 B, 12-way associative
LL cache:         18874368 B, 64 B, 18-way associative
Command:          ./P3.out input/input-profiling.txt
Data file:        cachegrind.out.40879
Events recorded:  Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Events shown:     Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Event sort order: Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Thresholds:       0.1 100 100 100 100 100 100 100 100
Include dirs:     
User annotated:   
Auto-annotation:  on

--------------------------------------------------------------------------------
Ir                     I1mr           ILmr           Dr                   D1mr            DLmr           Dw                   D1mw           DLmw           
--------------------------------------------------------------------------------
3,168,169,052 (100.0%) 2,733 (100.0%) 2,374 (100.0%) 642,747,275 (100.0%) 12,756 (100.0%) 7,521 (100.0%) 121,926,950 (100.0%) 2,396 (100.0%) 1,522 (100.0%)  PROGRAM TOTALS

--------------------------------------------------------------------------------
Ir                   I1mr         ILmr         Dr                   D1mr           DLmr           Dw                  D1mw           DLmw          file:function
--------------------------------------------------------------------------------
943,790,450 (29.79%)   7 ( 0.26%)   7 ( 0.29%) 361,200,000 (56.20%)     1 ( 0.01%)     1 ( 0.01%) 41,200,000 (33.79%)     0            0           /home/jovyan/Proyecto-intermedio-entropia/code/random_movement.cpp:random_movement(int&, int&, int&, std::vector<double, std::allocator<double> >&, std::mersenne_twister_engine<unsigned long, 32ul, 624ul, 397ul, 31ul, 2567483615ul, 11ul, 4294967295ul, 7ul, 2636928640ul, 15ul, 4022730752ul, 18ul, 1812433253ul>&, std::uniform_int_distribution<int>&, int&, int&)
840,512,824 (26.53%)   3 ( 0.11%)   3 ( 0.13%)  80,192,309 (12.48%)     0              0          40,192,309 (32.96%)     0            0           /usr/include/c++/12/bits/random.tcc:random_movement(int&, int&, int&, std::vector<double, std::allocator<double> >&, std::mersenne_twister_engine<unsigned long, 32ul, 624ul, 397ul, 31ul, 2567483615ul, 11ul, 4294967295ul, 7ul, 2636928640ul, 15ul, 4022730752ul, 18ul, 1812433253ul>&, std::uniform_int_distribution<int>&, int&, int&)
680,000,000 (21.46%)   3 ( 0.11%)   3 ( 0.13%)  80,000,000 (12.45%)     0              0                   0              0            0           /usr/include/c++/12/bits/uniform_int_dist.h:random_movement(int&, int&, int&, std::vector<double, std::allocator<double> >&, std::mersenne_twister_engine<unsigned long, 32ul, 624ul, 397ul, 31ul, 2567483615ul, 11ul, 4294967295ul, 7ul, 2636928640ul, 15ul, 4022730752ul, 18ul, 1812433253ul>&, std::uniform_int_distribution<int>&, int&, int&)
620,609,680 (19.59%)   4 ( 0.15%)   4 ( 0.17%)  80,256,956 (12.49%)     0              0          40,064,375 (32.86%)     0            0           /usr/include/c++/12/bits/random.tcc:std::mersenne_twister_engine<unsigned long, 32ul, 624ul, 397ul, 31ul, 2567483615ul, 11ul, 4294967295ul, 7ul, 2636928640ul, 15ul, 4022730752ul, 18ul, 1812433253ul>::_M_gen_rand()
 80,000,000 ( 2.53%)   0            0           40,000,000 ( 6.22%)     0              0                   0              0            0           /usr/include/c++/12/bits/stl_vector.h:random_movement(int&, int&, int&, std::vector<double, std::allocator<double> >&, std::mersenne_twister_engine<unsigned long, 32ul, 624ul, 397ul, 31ul, 2567483615ul, 11ul, 4294967295ul, 7ul, 2636928640ul, 15ul, 4022730752ul, 18ul, 1812433253ul>&, std::uniform_int_distribution<int>&, int&, int&)

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/12/bits/stl_vector.h
--------------------------------------------------------------------------------
Ir                  I1mr       ILmr       Dr                  D1mr       DLmr       Dw         D1mw       DLmw       

-- line 92 ----------------------------------------
         .          .          .                   .          .          .          .          .          .                 struct _Vector_impl_data
         .          .          .                   .          .          .          .          .          .                 {
         .          .          .                   .          .          .          .          .          .           	pointer _M_start;
         .          .          .                   .          .          .          .          .          .           	pointer _M_finish;
         .          .          .                   .          .          .          .          .          .           	pointer _M_end_of_storage;
         .          .          .                   .          .          .          .          .          .           
         .          .          .                   .          .          .          .          .          .           	_GLIBCXX20_CONSTEXPR
         .          .          .                   .          .          .          .          .          .           	_Vector_impl_data() _GLIBCXX_NOEXCEPT
        12 ( 0.00%) 1 ( 0.04%) 1 ( 0.04%)          0          0          0          6 ( 0.00%) 1 ( 0.04%) 0           	: _M_start(), _M_finish(), _M_end_of_storage()
         .          .          .                   .          .          .          .          .          .           	{ }
         .          .          .                   .          .          .          .          .          .           
         .          .          .                   .          .          .          .          .          .           #if __cplusplus >= 201103L
         .          .          .                   .          .          .          .          .          .           	_GLIBCXX20_CONSTEXPR
         .          .          .                   .          .          .          .          .          .           	_Vector_impl_data(_Vector_impl_data&& __x) noexcept
         .          .          .                   .          .          .          .          .          .           	: _M_start(__x._M_start), _M_finish(__x._M_finish),
         .          .          .                   .          .          .          .          .          .           	  _M_end_of_storage(__x._M_end_of_storage)
         .          .          .                   .          .          .          .          .          .           	{ __x._M_start = __x._M_finish = __x._M_end_of_storage = pointer(); }
-- line 108 ----------------------------------------
-- line 359 ----------------------------------------
         .          .          .                   .          .          .          .          .          .                 : _M_impl(_Tp_alloc_type(__a), std::move(__x._M_impl))
         .          .          .                   .          .          .          .          .          .                 { }
         .          .          .                   .          .          .          .          .          .           #endif
         .          .          .                   .          .          .          .          .          .           
         .          .          .                   .          .          .          .          .          .                 _GLIBCXX20_CONSTEXPR
         .          .          .                   .          .          .          .          .          .                 ~_Vector_base() _GLIBCXX_NOEXCEPT
         .          .          .                   .          .          .          .          .          .                 {
         .          .          .                   .          .          .          .          .          .           	_M_deallocate(_M_impl._M_start,
         6 ( 0.00%) 0          0                   3 ( 0.00%) 0          0          0          0          0           		      _M_impl._M_end_of_storage - _M_impl._M_start);
         .          .          .                   .          .          .          .          .          .                 }
         .          .          .                   .          .          .          .          .          .           
         .          .          .                   .          .          .          .          .          .               public:
         .          .          .                   .          .          .          .          .          .                 _Vector_impl _M_impl;
         .          .          .                   .          .          .          .          .          .           
         .          .          .                   .          .          .          .          .          .                 _GLIBCXX20_CONSTEXPR
         .          .          .                   .          .          .          .          .          .                 pointer
         .          .          .                   .          .          .          .          .          .                 _M_allocate(size_t __n)
         .          .          .                   .          .          .          .          .          .                 {
         .          .          .                   .          .          .          .          .          .           	typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
         8 ( 0.00%) 0          0                   0          0          0          0          0          0           	return __n != 0 ? _Tr::allocate(_M_impl, __n) : pointer();
         .          .          .                   .          .          .          .          .          .                 }
         .          .          .                   .          .          .          .          .          .           
         .          .          .                   .          .          .          .          .          .                 _GLIBCXX20_CONSTEXPR
         .          .          .                   .          .          .          .          .          .                 void
         .          .          .                   .          .          .          .          .          .                 _M_deallocate(pointer __p, size_t __n)
         .          .          .                   .          .          .          .          .          .                 {
         .          .          .                   .          .          .          .          .          .           	typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
        10 ( 0.00%) 1 ( 0.04%) 1 ( 0.04%)          0          0          0          0          0          0           	if (__p)
         .          .          .                   .          .          .          .          .          .           	  _Tr::deallocate(_M_impl, __p, __n);
         .          .          .                   .          .          .          .          .          .                 }
         .          .          .                   .          .          .          .          .          .           
         .          .          .                   .          .          .          .          .          .               protected:
         .          .          .                   .          .          .          .          .          .                 _GLIBCXX20_CONSTEXPR
         .          .          .                   .          .          .          .          .          .                 void
         .          .          .                   .          .          .          .          .          .                 _M_create_storage(size_t __n)
         .          .          .                   .          .          .          .          .          .                 {
         3 ( 0.00%) 0          0                   0          0          0          3 ( 0.00%) 0          0           	this->_M_impl._M_start = this->_M_allocate(__n);
         .          .          .                   .          .          .          .          .          .           	this->_M_impl._M_finish = this->_M_impl._M_start;
         9 ( 0.00%) 0          0                   0          0          0          3 ( 0.00%) 0          0           	this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
         .          .          .                   .          .          .          .          .          .                 }
         .          .          .                   .          .          .          .          .          .               };
         .          .          .                   .          .          .          .          .          .           
         .          .          .                   .          .          .          .          .          .             /**
         .          .          .                   .          .          .          .          .          .              *  @brief A standard container which offers fixed time access to
         .          .          .                   .          .          .          .          .          .              *  individual elements in any order.
         .          .          .                   .          .          .          .          .          .              *
         .          .          .                   .          .          .          .          .          .              *  @ingroup sequences
-- line 405 ----------------------------------------
-- line 556 ----------------------------------------
         .          .          .                   .          .          .          .          .          .                  *  @brief  Creates a %vector with copies of an exemplar element.
         .          .          .                   .          .          .          .          .          .                  *  @param  __n  The number of elements to initially create.
         .          .          .                   .          .          .          .          .          .                  *  @param  __value  An element to copy.
         .          .          .                   .          .          .          .          .          .                  *  @param  __a  An allocator.
         .          .          .                   .          .          .          .          .          .                  *
         .          .          .                   .          .          .          .          .          .                  *  This constructor fills the %vector with @a __n copies of @a __value.
         .          .          .                   .          .          .          .          .          .                  */
         .          .          .                   .          .          .          .          .          .                 _GLIBCXX20_CONSTEXPR
         9 ( 0.00%) 0          0                   0          0          0          9 ( 0.00%) 0          0                 vector(size_type __n, const value_type& __value,
         .          .          .                   .          .          .          .          .          .           	     const allocator_type& __a = allocator_type())
         .          .          .                   .          .          .          .          .          .                 : _Base(_S_check_init_len(__n, __a), __a)
        12 ( 0.00%) 0          0                  12 ( 0.00%) 0          0          0          0          0                 { _M_fill_initialize(__n, __value); }
         .          .          .                   .          .          .          .          .          .           #else
         .          .          .                   .          .          .          .          .          .                 /**
         .          .          .                   .          .          .          .          .          .                  *  @brief  Creates a %vector with copies of an exemplar element.
         .          .          .                   .          .          .          .          .          .                  *  @param  __n  The number of elements to initially create.
         .          .          .                   .          .          .          .          .          .                  *  @param  __value  An element to copy.
         .          .          .                   .          .          .          .          .          .                  *  @param  __a  An allocator.
         .          .          .                   .          .          .          .          .          .                  *
         .          .          .                   .          .          .          .          .          .                  *  This constructor fills the %vector with @a __n copies of @a __value.
-- line 575 ----------------------------------------
-- line 722 ----------------------------------------
         .          .          .                   .          .          .          .          .          .                  *  The dtor only erases the elements, and note that if the
         .          .          .                   .          .          .          .          .          .                  *  elements themselves are pointers, the pointed-to memory is
         .          .          .                   .          .          .          .          .          .                  *  not touched in any way.  Managing the pointer is the user's
         .          .          .                   .          .          .          .          .          .                  *  responsibility.
         .          .          .                   .          .          .          .          .          .                  */
         .          .          .                   .          .          .          .          .          .                 _GLIBCXX20_CONSTEXPR
         .          .          .                   .          .          .          .          .          .                 ~vector() _GLIBCXX_NOEXCEPT
         .          .          .                   .          .          .          .          .          .                 {
         3 ( 0.00%) 1 ( 0.04%) 1 ( 0.04%)          3 ( 0.00%) 0          0          0          0          0           	std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
         .          .          .                   .          .          .          .          .          .           		      _M_get_Tp_allocator());
         .          .          .                   .          .          .          .          .          .           	_GLIBCXX_ASAN_ANNOTATE_BEFORE_DEALLOC;
         .          .          .                   .          .          .          .          .          .                 }
         .          .          .                   .          .          .          .          .          .           
         .          .          .                   .          .          .          .          .          .                 /**
         .          .          .                   .          .          .          .          .          .                  *  @brief  %Vector assignment operator.
         .          .          .                   .          .          .          .          .          .                  *  @param  __x  A %vector of identical element and allocator types.
         .          .          .                   .          .          .          .          .          .                  *
-- line 738 ----------------------------------------
-- line 980 ----------------------------------------
         .          .          .                   .          .          .          .          .          .                 { return const_reverse_iterator(begin()); }
         .          .          .                   .          .          .          .          .          .           #endif
         .          .          .                   .          .          .          .          .          .           
         .          .          .                   .          .          .          .          .          .                 // [23.2.4.2] capacity
         .          .          .                   .          .          .          .          .          .                 /**  Returns the number of elements in the %vector.  */
         .          .          .                   .          .          .          .          .          .                 _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR
         .          .          .                   .          .          .          .          .          .                 size_type
         .          .          .                   .          .          .          .          .          .                 size() const _GLIBCXX_NOEXCEPT
        11 ( 0.00%) 0          0                   5 ( 0.00%) 0          0          2 ( 0.00%) 0          0                 { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
         .          .          .                   .          .          .          .          .          .           
         .          .          .                   .          .          .          .          .          .                 /**  Returns the size() of the largest possible %vector.  */
         .          .          .                   .          .          .          .          .          .                 _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR
         .          .          .                   .          .          .          .          .          .                 size_type
         .          .          .                   .          .          .          .          .          .                 max_size() const _GLIBCXX_NOEXCEPT
         .          .          .                   .          .          .          .          .          .                 { return _S_max_size(_M_get_Tp_allocator()); }
         .          .          .                   .          .          .          .          .          .           
         .          .          .                   .          .          .          .          .          .           #if __cplusplus >= 201103L
-- line 996 ----------------------------------------
-- line 1116 ----------------------------------------
         .          .          .                   .          .          .          .          .          .                  *  out_of_range lookups are not defined. (For checked lookups
         .          .          .                   .          .          .          .          .          .                  *  see at().)
         .          .          .                   .          .          .          .          .          .                  */
         .          .          .                   .          .          .          .          .          .                 _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR
         .          .          .                   .          .          .          .          .          .                 reference
         .          .          .                   .          .          .          .          .          .                 operator[](size_type __n) _GLIBCXX_NOEXCEPT
         .          .          .                   .          .          .          .          .          .                 {
         .          .          .                   .          .          .          .          .          .           	__glibcxx_requires_subscript(__n);
80,000,015 ( 2.53%) 1 ( 0.04%) 1 ( 0.04%) 40,000,002 ( 6.22%) 0          0          1 ( 0.00%) 0          0           	return *(this->_M_impl._M_start + __n);
         .          .          .                   .          .          .          .          .          .                 }
         .          .          .                   .          .          .          .          .          .           
         .          .          .                   .          .          .          .          .          .                 /**
         .          .          .                   .          .          .          .          .          .                  *  @brief  Subscript access to the data contained in the %vector.
         .          .          .                   .          .          .          .          .          .                  *  @param __n The index of the element for which data should be
         .          .          .                   .          .          .          .          .          .                  *  accessed.
         .          .          .                   .          .          .          .          .          .                  *  @return  Read-only (constant) reference to data.
         .          .          .                   .          .          .          .          .          .                  *
-- line 1132 ----------------------------------------
-- line 1693 ----------------------------------------
         .          .          .                   .          .          .          .          .          .           	}
         .          .          .                   .          .          .          .          .          .           
         .          .          .                   .          .          .          .          .          .                 // Called by the first initialize_dispatch above and by the
         .          .          .                   .          .          .          .          .          .                 // vector(n,value,a) constructor.
         .          .          .                   .          .          .          .          .          .                 _GLIBCXX20_CONSTEXPR
         .          .          .                   .          .          .          .          .          .                 void
         .          .          .                   .          .          .          .          .          .                 _M_fill_initialize(size_type __n, const value_type& __value)
         .          .          .                   .          .          .          .          .          .                 {
         3 ( 0.00%) 1 ( 0.04%) 1 ( 0.04%)          0          0          0          3 ( 0.00%) 0          0           	this->_M_impl._M_finish =
         .          .          .                   .          .          .          .          .          .           	  std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value,
         .          .          .                   .          .          .          .          .          .           					_M_get_Tp_allocator());
         .          .          .                   .          .          .          .          .          .                 }
         .          .          .                   .          .          .          .          .          .           
         .          .          .                   .          .          .          .          .          .           #if __cplusplus >= 201103L
         .          .          .                   .          .          .          .          .          .                 // Called by the vector(n) constructor.
         .          .          .                   .          .          .          .          .          .                 _GLIBCXX20_CONSTEXPR
         .          .          .                   .          .          .          .          .          .                 void
-- line 1709 ----------------------------------------
-- line 1896 ----------------------------------------
         .          .          .                   .          .          .          .          .          .           	const size_type __len = size() + (std::max)(size(), __n);
         .          .          .                   .          .          .          .          .          .           	return (__len < size() || __len > max_size()) ? max_size() : __len;
         .          .          .                   .          .          .          .          .          .                 }
         .          .          .                   .          .          .          .          .          .           
         .          .          .                   .          .          .          .          .          .                 // Called by constructors to check initial size.
         .          .          .                   .          .          .          .          .          .                 static _GLIBCXX20_CONSTEXPR size_type
         .          .          .                   .          .          .          .          .          .                 _S_check_init_len(size_type __n, const allocator_type& __a)
         .          .          .                   .          .          .          .          .          .                 {
        12 ( 0.00%) 2 ( 0.07%) 1 ( 0.04%)          0          0          0          0          0          0           	if (__n > _S_max_size(_Tp_alloc_type(__a)))
         .          .          .                   .          .          .          .          .          .           	  __throw_length_error(
         .          .          .                   .          .          .          .          .          .           	      __N("cannot create std::vector larger than max_size()"));
         .          .          .                   .          .          .          .          .          .           	return __n;
         .          .          .                   .          .          .          .          .          .                 }
         .          .          .                   .          .          .          .          .          .           
         .          .          .                   .          .          .          .          .          .                 static _GLIBCXX20_CONSTEXPR size_type
         .          .          .                   .          .          .          .          .          .                 _S_max_size(const _Tp_alloc_type& __a) _GLIBCXX_NOEXCEPT
         .          .          .                   .          .          .          .          .          .                 {
-- line 1912 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/jovyan/Proyecto-intermedio-entropia/code/random_movement.cpp
--------------------------------------------------------------------------------
Ir                   I1mr       ILmr       Dr                  D1mr       DLmr       Dw                  D1mw       DLmw       

          .          .          .                   .          .          .                   .          .          .           #include "random_movement.hpp"
          .          .          .                   .          .          .                   .          .          .           
    900,000 ( 0.03%) 2 ( 0.07%) 2 ( 0.08%)          0          0          0             800,000 ( 0.66%) 0          0           void random_movement(int &dim, int &n_molecules, int &lattice_size, std::vector<double> &molecules, std::mt19937 &gen, std::uniform_int_distribution<int> &direction_distribution, int &problem_id, int &count_out){
          .          .          .                   .          .          .                   .          .          .           
          .          .          .                   .          .          .                   .          .          .               // The constant movement passage of the simulation is defined
          .          .          .                   .          .          .                   .          .          .               double step_size = 0.005;
          .          .          .                   .          .          .                   .          .          .           
          .          .          .                   .          .          .                   .          .          .               // Definition of constants for particle movement
          .          .          .                   .          .          .                   .          .          .               int pos_x = 0, pos_y = 1;
          .          .          .                   .          .          .                   .          .          .               int direction = 0;
    500,000 ( 0.02%) 0          0             200,000 ( 0.03%) 0          0             100,000 ( 0.08%) 0          0               double limit = lattice_size/2.0; // Limit for a centered coordinate system
    200,000 ( 0.01%) 1 ( 0.04%) 1 ( 0.04%)    100,000 ( 0.02%) 1 ( 0.01%) 1 ( 0.01%)    100,000 ( 0.08%) 0          0               double m_limit = -1.0*limit;
          .          .          .                   .          .          .                   .          .          .           
    200,000 ( 0.01%) 0          0             100,000 ( 0.02%) 0          0                   0          0          0           	double hole = lattice_size/10.0;
    200,000 ( 0.01%) 0          0                   0          0          0             100,000 ( 0.08%) 0          0               double out = 2.0*lattice_size;
          .          .          .                   .          .          .                   .          .          .           
          .          .          .                   .          .          .                   .          .          .               // For contact with the wall or position outside the box, the movement in that direction is reflected twice
          .          .          .                   .          .          .                   .          .          .               double step_backward = 2.0*step_size; 
          .          .          .                   .          .          .                   .          .          .           
161,000,000 ( 5.08%) 1 ( 0.04%) 1 ( 0.04%) 80,100,000 (12.46%) 0          0             100,000 ( 0.08%) 0          0               for (int i = 0; i < n_molecules; i++){
          .          .          .                   .          .          .                   .          .          .                   direction = direction_distribution(gen);
160,000,000 ( 5.05%) 0          0          80,000,000 (12.45%) 0          0                   0          0          0           		if ((problem_id == 4) && (molecules[i*dim + pos_x] == out)) { direction = 4;}
          .          .          .                   .          .          .                   .          .          .           
169,985,792 ( 5.37%) 1 ( 0.04%) 1 ( 0.04%)          0          0          0                   0          0          0                   switch (direction) {
          .          .          .                   .          .          .                   .          .          .                       case 0: // Up
 50,012,770 ( 1.58%) 0          0          20,005,108 ( 3.11%) 0          0                   0          0          0                           molecules[i*dim + pos_y] += step_size;
          .          .          .                   .          .          .                   .          .          .                           if (molecules[i*dim + pos_y] >= limit) molecules[i*dim + pos_y] -= step_backward;
          .          .          .                   .          .          .                   .          .          .                           break;
          .          .          .                   .          .          .                   .          .          .           
          .          .          .                   .          .          .                   .          .          .                       case 1: // Down
 89,976,663 ( 2.84%) 0          0          39,989,628 ( 6.22%) 0          0           9,997,407 ( 8.20%) 0          0                           molecules[i*dim + pos_y] -= step_size;
 29,992,221 ( 0.95%) 0          0           9,997,407 ( 1.56%) 0          0                   0          0          0                           if (molecules[i*dim + pos_y] <= m_limit) {
          .          .          .                   .          .          .                   .          .          .           					molecules[i*dim + pos_y] += step_backward;
          .          .          .                   .          .          .                   .          .          .           					if ((problem_id == 4) && (std::fabs(molecules[i*dim + pos_x]) < hole)) {
          .          .          .                   .          .          .                   .          .          .           						molecules[i*dim + pos_x] = out;
          .          .          .                   .          .          .                   .          .          .           						count_out++;
          .          .          .                   .          .          .                   .          .          .           					} 
          .          .          .                   .          .          .                   .          .          .           				}
          .          .          .                   .          .          .                   .          .          .           				break;
          .          .          .                   .          .          .                   .          .          .           
          .          .          .                   .          .          .                   .          .          .                       case 2: // Left
 60,028,416 ( 1.89%) 1 ( 0.04%) 1 ( 0.04%) 40,018,944 ( 6.23%) 0          0                   0          0          0                           molecules[i*dim + pos_x] -= step_size;
 30,014,208 ( 0.95%) 0          0          10,004,736 ( 1.56%) 0          0                   0          0          0                           if (molecules[i*dim + pos_x] <= m_limit) molecules[i*dim + pos_x] += step_backward;
          .          .          .                   .          .          .                   .          .          .                           break;
          .          .          .                   .          .          .                   .          .          .           
          .          .          .                   .          .          .                   .          .          .                       case 3: // Right
 89,979,480 ( 2.84%) 0          0          59,986,320 ( 9.33%) 0          0                   0          0          0                           molecules[i*dim + pos_x] += step_size;
100,000,900 ( 3.16%) 1 ( 0.04%) 1 ( 0.04%) 19,997,857 ( 3.11%) 0          0          30,002,593 (24.61%) 0          0                           if (molecules[i*dim + pos_x] >= limit) molecules[i*dim + pos_x] -= step_backward;
          .          .          .                   .          .          .                   .          .          .                           break;
          .          .          .                   .          .          .                   .          .          .           
          .          .          .                   .          .          .                   .          .          .           			default:
          .          .          .                   .          .          .                   .          .          .           				break;
          .          .          .                   .          .          .                   .          .          .                   }
          .          .          .                   .          .          .                   .          .          .               }   
    800,002 ( 0.03%) 0          0             700,001 ( 0.11%) 0          0                   1 ( 0.00%) 0          0           }
--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/12/bits/uniform_int_dist.h
--------------------------------------------------------------------------------
Ir                   I1mr       ILmr       Dr                  D1mr       DLmr       Dw         D1mw       DLmw       

-- line 87 ----------------------------------------
          .          .          .                   .          .          .          .          .          .                 {
          .          .          .                   .          .          .          .          .          .           	typedef uniform_int_distribution<_IntType> distribution_type;
          .          .          .                   .          .          .          .          .          .           
          .          .          .                   .          .          .          .          .          .           	param_type() : param_type(0) { }
          .          .          .                   .          .          .          .          .          .           
          .          .          .                   .          .          .          .          .          .           	explicit
          .          .          .                   .          .          .          .          .          .           	param_type(_IntType __a,
          .          .          .                   .          .          .          .          .          .           		   _IntType __b = __gnu_cxx::__int_traits<_IntType>::__max)
          2 ( 0.00%) 1 ( 0.04%) 1 ( 0.04%)          1 ( 0.00%) 1 ( 0.01%) 1 ( 0.01%) 1 ( 0.00%) 0          0           	: _M_a(__a), _M_b(__b)
          .          .          .                   .          .          .          .          .          .           	{
          .          .          .                   .          .          .          .          .          .           	  __glibcxx_assert(_M_a <= _M_b);
          .          .          .                   .          .          .          .          .          .           	}
          .          .          .                   .          .          .          .          .          .           
          .          .          .                   .          .          .          .          .          .           	result_type
          .          .          .                   .          .          .          .          .          .           	a() const
          .          .          .                   .          .          .          .          .          .           	{ return _M_a; }
          .          .          .                   .          .          .          .          .          .           
-- line 103 ----------------------------------------
-- line 184 ----------------------------------------
          .          .          .                   .          .          .          .          .          .                 max() const
          .          .          .                   .          .          .          .          .          .                 { return this->b(); }
          .          .          .                   .          .          .          .          .          .           
          .          .          .                   .          .          .          .          .          .                 /**
          .          .          .                   .          .          .          .          .          .                  * @brief Generating functions.
          .          .          .                   .          .          .          .          .          .                  */
          .          .          .                   .          .          .          .          .          .                 template<typename _UniformRandomBitGenerator>
          .          .          .                   .          .          .          .          .          .           	result_type
 40,000,000 ( 1.26%) 0          0          40,000,000 ( 6.22%) 0          0          0          0          0           	operator()(_UniformRandomBitGenerator& __urng)
          .          .          .                   .          .          .          .          .          .                   { return this->operator()(__urng, _M_param); }
          .          .          .                   .          .          .          .          .          .           
          .          .          .                   .          .          .          .          .          .                 template<typename _UniformRandomBitGenerator>
          .          .          .                   .          .          .          .          .          .           	result_type
          .          .          .                   .          .          .          .          .          .           	operator()(_UniformRandomBitGenerator& __urng,
          .          .          .                   .          .          .          .          .          .           		   const param_type& __p);
          .          .          .                   .          .          .          .          .          .           
          .          .          .                   .          .          .          .          .          .                 template<typename _ForwardIterator,
-- line 200 ----------------------------------------
-- line 250 ----------------------------------------
          .          .          .                   .          .          .          .          .          .           	  static_assert(!_Up_traits::__is_signed, "U must be unsigned");
          .          .          .                   .          .          .          .          .          .           	  static_assert(!_Wp_traits::__is_signed, "W must be unsigned");
          .          .          .                   .          .          .          .          .          .           	  static_assert(_Wp_traits::__digits == (2 * _Up_traits::__digits),
          .          .          .                   .          .          .          .          .          .           			"W must be twice as wide as U");
          .          .          .                   .          .          .          .          .          .           
          .          .          .                   .          .          .          .          .          .           	  // reference: Fast Random Integer Generation in an Interval
          .          .          .                   .          .          .          .          .          .           	  // ACM Transactions on Modeling and Computer Simulation 29 (1), 2019
          .          .          .                   .          .          .          .          .          .           	  // https://arxiv.org/abs/1805.10941
 40,000,000 ( 1.26%) 0          0                   0          0          0          0          0          0           	  _Wp __product = _Wp(__g()) * _Wp(__range);
          .          .          .                   .          .          .          .          .          .           	  _Up __low = _Up(__product);
 80,000,000 ( 2.53%) 0          0                   0          0          0          0          0          0           	  if (__low < __range)
          .          .          .                   .          .          .          .          .          .           	    {
          .          .          .                   .          .          .          .          .          .           	      _Up __threshold = -__range % __range;
          .          .          .                   .          .          .          .          .          .           	      while (__low < __threshold)
          .          .          .                   .          .          .          .          .          .           		{
          .          .          .                   .          .          .          .          .          .           		  __product = _Wp(__g()) * _Wp(__range);
          .          .          .                   .          .          .          .          .          .           		  __low = _Up(__product);
          .          .          .                   .          .          .          .          .          .           		}
          .          .          .                   .          .          .          .          .          .           	    }
120,000,000 ( 3.79%) 1 ( 0.04%) 1 ( 0.04%)          0          0          0          0          0          0           	  return __product >> _Up_traits::__digits;
          .          .          .                   .          .          .          .          .          .           	}
          .          .          .                   .          .          .          .          .          .               };
          .          .          .                   .          .          .          .          .          .           
          .          .          .                   .          .          .          .          .          .             template<typename _IntType>
          .          .          .                   .          .          .          .          .          .               template<typename _UniformRandomBitGenerator>
          .          .          .                   .          .          .          .          .          .                 typename uniform_int_distribution<_IntType>::result_type
          .          .          .                   .          .          .          .          .          .                 uniform_int_distribution<_IntType>::
          .          .          .                   .          .          .          .          .          .                 operator()(_UniformRandomBitGenerator& __urng,
-- line 277 ----------------------------------------
-- line 282 ----------------------------------------
          .          .          .                   .          .          .          .          .          .           	typedef typename common_type<_Gresult_type, __utype>::type __uctype;
          .          .          .                   .          .          .          .          .          .           
          .          .          .                   .          .          .          .          .          .           	constexpr __uctype __urngmin = _UniformRandomBitGenerator::min();
          .          .          .                   .          .          .          .          .          .           	constexpr __uctype __urngmax = _UniformRandomBitGenerator::max();
          .          .          .                   .          .          .          .          .          .           	static_assert( __urngmin < __urngmax,
          .          .          .                   .          .          .          .          .          .           	    "Uniform random bit generator must define min() < max()");
          .          .          .                   .          .          .          .          .          .           	constexpr __uctype __urngrange = __urngmax - __urngmin;
          .          .          .                   .          .          .          .          .          .           
 80,000,000 ( 2.53%) 0          0                   0          0          0          0          0          0           	const __uctype __urange
 80,000,000 ( 2.53%) 0          0          40,000,000 ( 6.22%) 0          0          0          0          0           	  = __uctype(__param.b()) - __uctype(__param.a());
          .          .          .                   .          .          .          .          .          .           
          .          .          .                   .          .          .          .          .          .           	__uctype __ret;
120,000,000 ( 3.79%) 1 ( 0.04%) 1 ( 0.04%)          0          0          0          0          0          0           	if (__urngrange > __urange)
          .          .          .                   .          .          .          .          .          .           	  {
          .          .          .                   .          .          .          .          .          .           	    // downscaling
          .          .          .                   .          .          .          .          .          .           
 40,000,000 ( 1.26%) 0          0                   0          0          0          0          0          0           	    const __uctype __uerange = __urange + 1; // __urange can be zero
          .          .          .                   .          .          .          .          .          .           
          .          .          .                   .          .          .          .          .          .           #if defined __UINT64_TYPE__ && defined __UINT32_TYPE__
          .          .          .                   .          .          .          .          .          .           #if __SIZEOF_INT128__
          .          .          .                   .          .          .          .          .          .           	    if _GLIBCXX17_CONSTEXPR (__urngrange == __UINT64_MAX__)
          .          .          .                   .          .          .          .          .          .           	      {
          .          .          .                   .          .          .          .          .          .           		// __urng produces values that use exactly 64-bits,
          .          .          .                   .          .          .          .          .          .           		// so use 128-bit integers to downscale to desired range.
          .          .          .                   .          .          .          .          .          .           		__UINT64_TYPE__ __u64erange = __uerange;
-- line 306 ----------------------------------------
-- line 308 ----------------------------------------
          .          .          .                   .          .          .          .          .          .           							       __u64erange);
          .          .          .                   .          .          .          .          .          .           	      }
          .          .          .                   .          .          .          .          .          .           	    else
          .          .          .                   .          .          .          .          .          .           #endif
          .          .          .                   .          .          .          .          .          .           	    if _GLIBCXX17_CONSTEXPR (__urngrange == __UINT32_MAX__)
          .          .          .                   .          .          .          .          .          .           	      {
          .          .          .                   .          .          .          .          .          .           		// __urng produces values that use exactly 32-bits,
          .          .          .                   .          .          .          .          .          .           		// so use 64-bit integers to downscale to desired range.
 40,000,000 ( 1.26%) 0          0                   0          0          0          0          0          0           		__UINT32_TYPE__ __u32erange = __uerange;
          .          .          .                   .          .          .          .          .          .           		__ret = _S_nd<__UINT64_TYPE__>(__urng, __u32erange);
          .          .          .                   .          .          .          .          .          .           	      }
          .          .          .                   .          .          .          .          .          .           	    else
          .          .          .                   .          .          .          .          .          .           #endif
          .          .          .                   .          .          .          .          .          .           	      {
          .          .          .                   .          .          .          .          .          .           		// fallback case (2 divisions)
          .          .          .                   .          .          .          .          .          .           		const __uctype __scaling = __urngrange / __uerange;
          .          .          .                   .          .          .          .          .          .           		const __uctype __past = __uerange * __scaling;
-- line 324 ----------------------------------------
-- line 353 ----------------------------------------
          .          .          .                   .          .          .          .          .          .           			 (__urng, param_type(0, __urange / __uerngrange)));
          .          .          .                   .          .          .          .          .          .           		__ret = __tmp + (__uctype(__urng()) - __urngmin);
          .          .          .                   .          .          .          .          .          .           	      }
          .          .          .                   .          .          .          .          .          .           	    while (__ret > __urange || __ret < __tmp);
          .          .          .                   .          .          .          .          .          .           	  }
          .          .          .                   .          .          .          .          .          .           	else
          .          .          .                   .          .          .          .          .          .           	  __ret = __uctype(__urng()) - __urngmin;
          .          .          .                   .          .          .          .          .          .           
 40,000,000 ( 1.26%) 1 ( 0.04%) 1 ( 0.04%)          0          0          0          0          0          0           	return __ret + __param.a();
          .          .          .                   .          .          .          .          .          .                 }
          .          .          .                   .          .          .          .          .          .           
          .          .          .                   .          .          .          .          .          .           
          .          .          .                   .          .          .          .          .          .             template<typename _IntType>
          .          .          .                   .          .          .          .          .          .               template<typename _ForwardIterator,
          .          .          .                   .          .          .          .          .          .           	     typename _UniformRandomBitGenerator>
          .          .          .                   .          .          .          .          .          .                 void
          .          .          .                   .          .          .          .          .          .                 uniform_int_distribution<_IntType>::
-- line 369 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/12/bits/random.tcc
--------------------------------------------------------------------------------
Ir                   I1mr       ILmr       Dr                  D1mr       DLmr       Dw                  D1mw        DLmw       

-- line 322 ----------------------------------------
          .          .          .                   .          .          .                   .           .          .           	   _UIntType __a, size_t __u, _UIntType __d, size_t __s,
          .          .          .                   .          .          .                   .           .          .           	   _UIntType __b, size_t __t, _UIntType __c, size_t __l,
          .          .          .                   .          .          .                   .           .          .           	   _UIntType __f>
          .          .          .                   .          .          .                   .           .          .               void
          .          .          .                   .          .          .                   .           .          .               mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
          .          .          .                   .          .          .                   .           .          .           			    __s, __b, __t, __c, __l, __f>::
          .          .          .                   .          .          .                   .           .          .               seed(result_type __sd)
          .          .          .                   .          .          .                   .           .          .               {
          1 ( 0.00%) 0          0                   0          0          0                   1 ( 0.00%)  0          0                 _M_x[0] = __detail::__mod<_UIntType,
          .          .          .                   .          .          .                   .           .          .           	__detail::_Shift<_UIntType, __w>::__value>(__sd);
          .          .          .                   .          .          .                   .           .          .           
      1,875 ( 0.00%) 1 ( 0.04%) 1 ( 0.04%)          1 ( 0.00%) 0          0                   0           0          0                 for (size_t __i = 1; __i < state_size; ++__i)
          .          .          .                   .          .          .                   .           .          .           	{
          .          .          .                   .          .          .                   .           .          .           	  _UIntType __x = _M_x[__i - 1];
      1,869 ( 0.00%) 0          0                   0          0          0                   0           0          0           	  __x ^= __x >> (__w - 2);
        623 ( 0.00%) 0          0                   0          0          0                   0           0          0           	  __x *= __f;
          .          .          .                   .          .          .                   .           .          .           	  __x += __detail::__mod<_UIntType, __n>(__i);
        623 ( 0.00%) 0          0                   0          0          0                 623 ( 0.00%) 65 ( 2.71%) 0           	  _M_x[__i] = __detail::__mod<_UIntType,
          .          .          .                   .          .          .                   .           .          .           	    __detail::_Shift<_UIntType, __w>::__value>(__x);
          .          .          .                   .          .          .                   .           .          .           	}
          2 ( 0.00%) 0          0                   0          0          0                   2 ( 0.00%)  0          0                 _M_p = state_size;
          .          .          .                   .          .          .                   .           .          .               }
          .          .          .                   .          .          .                   .           .          .           
          .          .          .                   .          .          .                   .           .          .             template<typename _UIntType,
          .          .          .                   .          .          .                   .           .          .           	   size_t __w, size_t __n, size_t __m, size_t __r,
          .          .          .                   .          .          .                   .           .          .           	   _UIntType __a, size_t __u, _UIntType __d, size_t __s,
          .          .          .                   .          .          .                   .           .          .           	   _UIntType __b, size_t __t, _UIntType __c, size_t __l,
          .          .          .                   .          .          .                   .           .          .           	   _UIntType __f>
          .          .          .                   .          .          .                   .           .          .               template<typename _Sseq>
-- line 350 ----------------------------------------
-- line 389 ----------------------------------------
          .          .          .                   .          .          .                   .           .          .                 }
          .          .          .                   .          .          .                   .           .          .           
          .          .          .                   .          .          .                   .           .          .             template<typename _UIntType, size_t __w,
          .          .          .                   .          .          .                   .           .          .           	   size_t __n, size_t __m, size_t __r,
          .          .          .                   .          .          .                   .           .          .           	   _UIntType __a, size_t __u, _UIntType __d, size_t __s,
          .          .          .                   .          .          .                   .           .          .           	   _UIntType __b, size_t __t, _UIntType __c, size_t __l,
          .          .          .                   .          .          .                   .           .          .           	   _UIntType __f>
          .          .          .                   .          .          .                   .           .          .               void
    256,412 ( 0.01%) 1 ( 0.04%) 1 ( 0.04%)     64,103 ( 0.01%) 0          0                   0           0          0               mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
          .          .          .                   .          .          .                   .           .          .           			    __s, __b, __t, __c, __l, __f>::
          .          .          .                   .          .          .                   .           .          .               _M_gen_rand(void)
          .          .          .                   .          .          .                   .           .          .               {
          .          .          .                   .          .          .                   .           .          .                 const _UIntType __upper_mask = (~_UIntType()) << __r;
          .          .          .                   .          .          .                   .           .          .                 const _UIntType __lower_mask = ~__upper_mask;
          .          .          .                   .          .          .                   .           .          .           
 43,782,349 ( 1.38%) 0          0              64,103 ( 0.01%) 0          0                   0           0          0                 for (size_t __k = 0; __k < (__n - __m); ++__k)
          .          .          .                   .          .          .                   .           .          .                   {
 43,654,143 ( 1.38%) 0          0                   0          0          0                   0           0          0           	  _UIntType __y = ((_M_x[__k] & __upper_mask)
 43,654,143 ( 1.38%) 0          0          14,551,381 ( 2.26%) 0          0                   0           0          0           			   | (_M_x[__k + 1] & __lower_mask));
 58,205,524 ( 1.84%) 1 ( 0.04%) 1 ( 0.04%) 14,551,381 ( 2.26%) 0          0          14,551,381 (11.93%)  0          0           	  _M_x[__k] = (_M_x[__k + __m] ^ (__y >> 1)
 36,570,240 ( 1.15%) 1 ( 0.04%) 1 ( 0.04%)          0          0          0                   0           0          0           		       ^ ((__y & 0x01) ? __a : 0));
          .          .          .                   .          .          .                   .           .          .                   }
          .          .          .                   .          .          .                   .           .          .           
 76,154,364 ( 2.40%) 0          0                   0          0          0                   0           0          0                 for (size_t __k = (__n - __m); __k < (__n - 1); ++__k)
          .          .          .                   .          .          .                   .           .          .           	{
 76,154,364 ( 2.40%) 0          0                   0          0          0                   0           0          0           	  _UIntType __y = ((_M_x[__k] & __upper_mask)
 76,154,364 ( 2.40%) 0          0          25,384,788 ( 3.95%) 0          0                   0           0          0           			   | (_M_x[__k + 1] & __lower_mask));
101,539,152 ( 3.20%) 1 ( 0.04%) 1 ( 0.04%) 25,384,788 ( 3.95%) 0          0          25,384,788 (20.82%)  0          0           	  _M_x[__k] = (_M_x[__k + (__m - __n)] ^ (__y >> 1)
 63,587,282 ( 2.01%) 0          0                   0          0          0                   0           0          0           		       ^ ((__y & 0x01) ? __a : 0));
          .          .          .                   .          .          .                   .           .          .           	}
          .          .          .                   .          .          .                   .           .          .           
    192,309 ( 0.01%) 0          0              64,103 ( 0.01%) 0          0                   0           0          0                 _UIntType __y = ((_M_x[__n - 1] & __upper_mask)
    128,206 ( 0.00%) 0          0              64,103 ( 0.01%) 0          0                   0           0          0           		       | (_M_x[0] & __lower_mask));
    256,412 ( 0.01%) 0          0              64,103 ( 0.01%) 0          0              64,103 ( 0.05%)  0          0                 _M_x[__n - 1] = (_M_x[__m - 1] ^ (__y >> 1)
    192,210 ( 0.01%) 0          0                   0          0          0                   0           0          0           		       ^ ((__y & 0x01) ? __a : 0));
     64,103 ( 0.00%) 0          0                   0          0          0              64,103 ( 0.05%)  0          0                 _M_p = 0;
     64,103 ( 0.00%) 0          0              64,103 ( 0.01%) 0          0                   0           0          0               }
          .          .          .                   .          .          .                   .           .          .           
          .          .          .                   .          .          .                   .           .          .             template<typename _UIntType, size_t __w,
          .          .          .                   .          .          .                   .           .          .           	   size_t __n, size_t __m, size_t __r,
          .          .          .                   .          .          .                   .           .          .           	   _UIntType __a, size_t __u, _UIntType __d, size_t __s,
          .          .          .                   .          .          .                   .           .          .           	   _UIntType __b, size_t __t, _UIntType __c, size_t __l,
          .          .          .                   .          .          .                   .           .          .           	   _UIntType __f>
          .          .          .                   .          .          .                   .           .          .               void
          .          .          .                   .          .          .                   .           .          .               mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
-- line 433 ----------------------------------------
-- line 450 ----------------------------------------
          .          .          .                   .          .          .                   .           .          .               typename
          .          .          .                   .          .          .                   .           .          .               mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
          .          .          .                   .          .          .                   .           .          .           			    __s, __b, __t, __c, __l, __f>::result_type
          .          .          .                   .          .          .                   .           .          .               mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
          .          .          .                   .          .          .                   .           .          .           			    __s, __b, __t, __c, __l, __f>::
          .          .          .                   .          .          .                   .           .          .               operator()()
          .          .          .                   .          .          .                   .           .          .               {
          .          .          .                   .          .          .                   .           .          .                 // Reload the vector - cost is O(n) amortized over n calls.
120,000,000 ( 3.79%) 1 ( 0.04%) 1 ( 0.04%) 40,000,000 ( 6.22%) 0          0                   0           0          0                 if (_M_p >= state_size)
    256,412 ( 0.01%) 1 ( 0.04%) 1 ( 0.04%)          0          0          0             192,309 ( 0.16%)  0          0           	_M_gen_rand();
          .          .          .                   .          .          .                   .           .          .           
          .          .          .                   .          .          .                   .           .          .                 // Calculate o(x(i)).
120,256,412 ( 3.80%) 0          0          40,192,309 ( 6.25%) 0          0          40,000,000 (32.81%)  0          0                 result_type __z = _M_x[_M_p++];
160,000,000 ( 5.05%) 0          0                   0          0          0                   0           0          0                 __z ^= (__z >> __u) & __d;
160,000,000 ( 5.05%) 1 ( 0.04%) 1 ( 0.04%)          0          0          0                   0           0          0                 __z ^= (__z << __s) & __b;
160,000,000 ( 5.05%) 0          0                   0          0          0                   0           0          0                 __z ^= (__z << __t) & __c;
120,000,000 ( 3.79%) 0          0                   0          0          0                   0           0          0                 __z ^= (__z >> __l);
          .          .          .                   .          .          .                   .           .          .           
          .          .          .                   .          .          .                   .           .          .                 return __z;
          .          .          .                   .          .          .                   .           .          .               }
          .          .          .                   .          .          .                   .           .          .           
          .          .          .                   .          .          .                   .           .          .             template<typename _UIntType, size_t __w,
          .          .          .                   .          .          .                   .           .          .           	   size_t __n, size_t __m, size_t __r,
          .          .          .                   .          .          .                   .           .          .           	   _UIntType __a, size_t __u, _UIntType __d, size_t __s,
          .          .          .                   .          .          .                   .           .          .           	   _UIntType __b, size_t __t, _UIntType __c, size_t __l,
-- line 474 ----------------------------------------

--------------------------------------------------------------------------------
Ir                     I1mr        ILmr        Dr                   D1mr       DLmr       Dw                   D1mw        DLmw       
--------------------------------------------------------------------------------
3,164,918,064 (99.90%) 26 ( 0.95%) 25 ( 1.05%) 641,649,293 (99.83%) 2 ( 0.02%) 2 ( 0.03%) 121,457,339 (99.61%) 66 ( 2.75%) 0           events annotated

