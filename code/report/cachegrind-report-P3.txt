--------------------------------------------------------------------------------
I1 cache:         32768 B, 64 B, 8-way associative
D1 cache:         49152 B, 64 B, 12-way associative
LL cache:         18874368 B, 64 B, 18-way associative
Command:          ./P3.out input/input-profiling.txt
Data file:        cachegrind.out.9861
Events recorded:  Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Events shown:     Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Event sort order: Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Thresholds:       0.1 100 100 100 100 100 100 100 100
Include dirs:     
User annotated:   
Auto-annotation:  on

--------------------------------------------------------------------------------
Ir                      I1mr           ILmr           Dr                     D1mr            DLmr           Dw                   D1mw           DLmw           
--------------------------------------------------------------------------------
18,937,680,008 (100.0%) 3,197 (100.0%) 2,434 (100.0%) 3,841,637,784 (100.0%) 12,870 (100.0%) 7,561 (100.0%) 728,467,164 (100.0%) 2,479 (100.0%) 1,590 (100.0%)  PROGRAM TOTALS

--------------------------------------------------------------------------------
Ir                     I1mr         ILmr         Dr                     D1mr           DLmr           Dw                   D1mw           DLmw          file:function
--------------------------------------------------------------------------------
5,643,930,235 (29.80%)   8 ( 0.25%)   8 ( 0.33%) 2,160,007,595 (56.23%)     1 ( 0.01%)     1 ( 0.01%) 246,376,000 (33.82%)     0            0           /home/jovyan/Proyecto-intermedio-entropia/code/random_movement.cpp:random_movement(int&, int&, int&, std::vector<double, std::allocator<double> >&, std::mersenne_twister_engine<unsigned long, 32ul, 624ul, 397ul, 31ul, 2567483615ul, 11ul, 4294967295ul, 7ul, 2636928640ul, 15ul, 4022730752ul, 18ul, 1812433253ul>&, std::uniform_int_distribution<int>&, int&, int&)
5,026,266,672 (26.54%)   4 ( 0.13%)   4 ( 0.16%)   479,550,002 (12.48%)     0              0          240,350,002 (32.99%)     0            0           /usr/include/c++/12/bits/random.tcc:random_movement(int&, int&, int&, std::vector<double, std::allocator<double> >&, std::mersenne_twister_engine<unsigned long, 32ul, 624ul, 397ul, 31ul, 2567483615ul, 11ul, 4294967295ul, 7ul, 2636928640ul, 15ul, 4022730752ul, 18ul, 1812433253ul>&, std::uniform_int_distribution<int>&, int&, int&)
4,066,400,000 (21.47%)   3 ( 0.09%)   3 ( 0.12%)   478,400,000 (12.45%)     0              0                    0              0            0           /usr/include/c++/12/bits/uniform_int_dist.h:random_movement(int&, int&, int&, std::vector<double, std::allocator<double> >&, std::mersenne_twister_engine<unsigned long, 32ul, 624ul, 397ul, 31ul, 2567483615ul, 11ul, 4294967295ul, 7ul, 2636928640ul, 15ul, 4022730752ul, 18ul, 1812433253ul>&, std::uniform_int_distribution<int>&, int&, int&)
3,711,239,466 (19.60%)   5 ( 0.16%)   4 ( 0.16%)   479,934,168 (12.49%)     0              0          239,583,750 (32.89%)     0            0           /usr/include/c++/12/bits/random.tcc:std::mersenne_twister_engine<unsigned long, 32ul, 624ul, 397ul, 31ul, 2567483615ul, 11ul, 4294967295ul, 7ul, 2636928640ul, 15ul, 4022730752ul, 18ul, 1812433253ul>::_M_gen_rand()
  478,400,000 ( 2.53%)   0            0            239,200,000 ( 6.23%)     0              0                    0              0            0           /usr/include/c++/12/bits/stl_vector.h:random_movement(int&, int&, int&, std::vector<double, std::allocator<double> >&, std::mersenne_twister_engine<unsigned long, 32ul, 624ul, 397ul, 31ul, 2567483615ul, 11ul, 4294967295ul, 7ul, 2636928640ul, 15ul, 4022730752ul, 18ul, 1812433253ul>&, std::uniform_int_distribution<int>&, int&, int&)

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/12/bits/random.tcc
--------------------------------------------------------------------------------
Ir                   I1mr       ILmr       Dr                   D1mr       DLmr       Dw                   D1mw        DLmw       

-- line 322 ----------------------------------------
          .          .          .                    .          .          .                    .           .          .           	   _UIntType __a, size_t __u, _UIntType __d, size_t __s,
          .          .          .                    .          .          .                    .           .          .           	   _UIntType __b, size_t __t, _UIntType __c, size_t __l,
          .          .          .                    .          .          .                    .           .          .           	   _UIntType __f>
          .          .          .                    .          .          .                    .           .          .               void
          .          .          .                    .          .          .                    .           .          .               mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
          .          .          .                    .          .          .                    .           .          .           			    __s, __b, __t, __c, __l, __f>::
          .          .          .                    .          .          .                    .           .          .               seed(result_type __sd)
          .          .          .                    .          .          .                    .           .          .               {
          1 ( 0.00%) 0          0                    0          0          0                    1 ( 0.00%)  0          0                 _M_x[0] = __detail::__mod<_UIntType,
          .          .          .                    .          .          .                    .           .          .           	__detail::_Shift<_UIntType, __w>::__value>(__sd);
          .          .          .                    .          .          .                    .           .          .           
      2,172 ( 0.00%) 0          0                    0          0          0                    0           0          0                 for (size_t __i = 1; __i < state_size; ++__i)
          .          .          .                    .          .          .                    .           .          .           	{
          .          .          .                    .          .          .                    .           .          .           	  _UIntType __x = _M_x[__i - 1];
      1,869 ( 0.00%) 0          0                    0          0          0                    0           0          0           	  __x ^= __x >> (__w - 2);
        623 ( 0.00%) 1 ( 0.03%) 1 ( 0.04%)           0          0          0                    0           0          0           	  __x *= __f;
          .          .          .                    .          .          .                    .           .          .           	  __x += __detail::__mod<_UIntType, __n>(__i);
        623 ( 0.00%) 0          0                    0          0          0                  623 ( 0.00%) 71 ( 2.86%) 0           	  _M_x[__i] = __detail::__mod<_UIntType,
          .          .          .                    .          .          .                    .           .          .           	    __detail::_Shift<_UIntType, __w>::__value>(__x);
          .          .          .                    .          .          .                    .           .          .           	}
          2 ( 0.00%) 0          0                    0          0          0                    2 ( 0.00%)  1 ( 0.04%) 0                 _M_p = state_size;
          .          .          .                    .          .          .                    .           .          .               }
          .          .          .                    .          .          .                    .           .          .           
          .          .          .                    .          .          .                    .           .          .             template<typename _UIntType,
          .          .          .                    .          .          .                    .           .          .           	   size_t __w, size_t __n, size_t __m, size_t __r,
          .          .          .                    .          .          .                    .           .          .           	   _UIntType __a, size_t __u, _UIntType __d, size_t __s,
          .          .          .                    .          .          .                    .           .          .           	   _UIntType __b, size_t __t, _UIntType __c, size_t __l,
          .          .          .                    .          .          .                    .           .          .           	   _UIntType __f>
          .          .          .                    .          .          .                    .           .          .               template<typename _Sseq>
-- line 350 ----------------------------------------
-- line 389 ----------------------------------------
          .          .          .                    .          .          .                    .           .          .                 }
          .          .          .                    .          .          .                    .           .          .           
          .          .          .                    .          .          .                    .           .          .             template<typename _UIntType, size_t __w,
          .          .          .                    .          .          .                    .           .          .           	   size_t __n, size_t __m, size_t __r,
          .          .          .                    .          .          .                    .           .          .           	   _UIntType __a, size_t __u, _UIntType __d, size_t __s,
          .          .          .                    .          .          .                    .           .          .           	   _UIntType __b, size_t __t, _UIntType __c, size_t __l,
          .          .          .                    .          .          .                    .           .          .           	   _UIntType __f>
          .          .          .                    .          .          .                    .           .          .               void
  1,533,336 ( 0.01%) 1 ( 0.03%) 1 ( 0.04%)     383,334 ( 0.01%) 0          0                    0           0          0               mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
          .          .          .                    .          .          .                    .           .          .           			    __s, __b, __t, __c, __l, __f>::
          .          .          .                    .          .          .                    .           .          .               _M_gen_rand(void)
          .          .          .                    .          .          .                    .           .          .               {
          .          .          .                    .          .          .                    .           .          .                 const _UIntType __upper_mask = (~_UIntType()) << __r;
          .          .          .                    .          .          .                    .           .          .                 const _UIntType __lower_mask = ~__upper_mask;
          .          .          .                    .          .          .                    .           .          .           
261,817,122 ( 1.38%) 1 ( 0.03%) 1 ( 0.04%)     383,334 ( 0.01%) 0          0                    0           0          0                 for (size_t __k = 0; __k < (__n - __m); ++__k)
          .          .          .                    .          .          .                    .           .          .                   {
261,050,454 ( 1.38%) 1 ( 0.03%) 1 ( 0.04%)           0          0          0                    0           0          0           	  _UIntType __y = ((_M_x[__k] & __upper_mask)
261,050,454 ( 1.38%) 0          0           87,016,818 ( 2.27%) 0          0                    0           0          0           			   | (_M_x[__k + 1] & __lower_mask));
348,067,272 ( 1.84%) 0          0           87,016,818 ( 2.27%) 0          0           87,016,818 (11.95%)  0          0           	  _M_x[__k] = (_M_x[__k + __m] ^ (__y >> 1)
218,692,352 ( 1.15%) 0          0                    0          0          0                    0           0          0           		       ^ ((__y & 0x01) ? __a : 0));
          .          .          .                    .          .          .                    .           .          .                   }
          .          .          .                    .          .          .                    .           .          .           
455,400,792 ( 2.40%) 0          0                    0          0          0                    0           0          0                 for (size_t __k = (__n - __m); __k < (__n - 1); ++__k)
          .          .          .                    .          .          .                    .           .          .           	{
455,400,792 ( 2.40%) 0          0                    0          0          0                    0           0          0           	  _UIntType __y = ((_M_x[__k] & __upper_mask)
455,400,792 ( 2.40%) 0          0          151,800,264 ( 3.95%) 0          0                    0           0          0           			   | (_M_x[__k + 1] & __lower_mask));
607,201,056 ( 3.21%) 1 ( 0.03%) 1 ( 0.04%) 151,800,264 ( 3.95%) 0          0          151,800,264 (20.84%)  0          0           	  _M_x[__k] = (_M_x[__k + (__m - __n)] ^ (__y >> 1)
380,257,832 ( 2.01%) 0          0                    0          0          0                    0           0          0           		       ^ ((__y & 0x01) ? __a : 0));
          .          .          .                    .          .          .                    .           .          .           	}
          .          .          .                    .          .          .                    .           .          .           
  1,150,002 ( 0.01%) 0          0              383,334 ( 0.01%) 0          0                    0           0          0                 _UIntType __y = ((_M_x[__n - 1] & __upper_mask)
    766,668 ( 0.00%) 0          0              383,334 ( 0.01%) 0          0                    0           0          0           		       | (_M_x[0] & __lower_mask));
  1,533,336 ( 0.01%) 1 ( 0.03%) 0              383,334 ( 0.01%) 0          0              383,334 ( 0.05%)  0          0                 _M_x[__n - 1] = (_M_x[__m - 1] ^ (__y >> 1)
  1,150,538 ( 0.01%) 0          0                    0          0          0                    0           0          0           		       ^ ((__y & 0x01) ? __a : 0));
    383,334 ( 0.00%) 0          0                    0          0          0              383,334 ( 0.05%)  0          0                 _M_p = 0;
    383,334 ( 0.00%) 0          0              383,334 ( 0.01%) 0          0                    0           0          0               }
          .          .          .                    .          .          .                    .           .          .           
          .          .          .                    .          .          .                    .           .          .             template<typename _UIntType, size_t __w,
          .          .          .                    .          .          .                    .           .          .           	   size_t __n, size_t __m, size_t __r,
          .          .          .                    .          .          .                    .           .          .           	   _UIntType __a, size_t __u, _UIntType __d, size_t __s,
          .          .          .                    .          .          .                    .           .          .           	   _UIntType __b, size_t __t, _UIntType __c, size_t __l,
          .          .          .                    .          .          .                    .           .          .           	   _UIntType __f>
          .          .          .                    .          .          .                    .           .          .               void
          .          .          .                    .          .          .                    .           .          .               mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
-- line 433 ----------------------------------------
-- line 450 ----------------------------------------
          .          .          .                    .          .          .                    .           .          .               typename
          .          .          .                    .          .          .                    .           .          .               mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
          .          .          .                    .          .          .                    .           .          .           			    __s, __b, __t, __c, __l, __f>::result_type
          .          .          .                    .          .          .                    .           .          .               mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
          .          .          .                    .          .          .                    .           .          .           			    __s, __b, __t, __c, __l, __f>::
          .          .          .                    .          .          .                    .           .          .               operator()()
          .          .          .                    .          .          .                    .           .          .               {
          .          .          .                    .          .          .                    .           .          .                 // Reload the vector - cost is O(n) amortized over n calls.
717,600,000 ( 3.79%) 2 ( 0.06%) 2 ( 0.08%) 239,200,000 ( 6.23%) 0          0                    0           0          0                 if (_M_p >= state_size)
  1,533,336 ( 0.01%) 1 ( 0.03%) 1 ( 0.04%)           0          0          0            1,150,002 ( 0.16%)  0          0           	_M_gen_rand();
          .          .          .                    .          .          .                    .           .          .           
          .          .          .                    .          .          .                    .           .          .                 // Calculate o(x(i)).
719,133,336 ( 3.80%) 0          0          240,350,002 ( 6.26%) 0          0          239,200,000 (32.84%)  0          0                 result_type __z = _M_x[_M_p++];
956,800,000 ( 5.05%) 0          0                    0          0          0                    0           0          0                 __z ^= (__z >> __u) & __d;
956,800,000 ( 5.05%) 0          0                    0          0          0                    0           0          0                 __z ^= (__z << __s) & __b;
956,800,000 ( 5.05%) 1 ( 0.03%) 1 ( 0.04%)           0          0          0                    0           0          0                 __z ^= (__z << __t) & __c;
717,600,000 ( 3.79%) 0          0                    0          0          0                    0           0          0                 __z ^= (__z >> __l);
          .          .          .                    .          .          .                    .           .          .           
          .          .          .                    .          .          .                    .           .          .                 return __z;
          .          .          .                    .          .          .                    .           .          .               }
          .          .          .                    .          .          .                    .           .          .           
          .          .          .                    .          .          .                    .           .          .             template<typename _UIntType, size_t __w,
          .          .          .                    .          .          .                    .           .          .           	   size_t __n, size_t __m, size_t __r,
          .          .          .                    .          .          .                    .           .          .           	   _UIntType __a, size_t __u, _UIntType __d, size_t __s,
          .          .          .                    .          .          .                    .           .          .           	   _UIntType __b, size_t __t, _UIntType __c, size_t __l,
-- line 474 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/12/bits/stl_vector.h
--------------------------------------------------------------------------------
Ir                   I1mr       ILmr       Dr                   D1mr       DLmr       Dw          D1mw       DLmw       

-- line 92 ----------------------------------------
          .          .          .                    .          .          .           .          .          .                 struct _Vector_impl_data
          .          .          .                    .          .          .           .          .          .                 {
          .          .          .                    .          .          .           .          .          .           	pointer _M_start;
          .          .          .                    .          .          .           .          .          .           	pointer _M_finish;
          .          .          .                    .          .          .           .          .          .           	pointer _M_end_of_storage;
          .          .          .                    .          .          .           .          .          .           
          .          .          .                    .          .          .           .          .          .           	_GLIBCXX20_CONSTEXPR
          .          .          .                    .          .          .           .          .          .           	_Vector_impl_data() _GLIBCXX_NOEXCEPT
         20 ( 0.00%) 0          0                    0          0          0          10 ( 0.00%) 2 ( 0.08%) 0           	: _M_start(), _M_finish(), _M_end_of_storage()
          .          .          .                    .          .          .           .          .          .           	{ }
          .          .          .                    .          .          .           .          .          .           
          .          .          .                    .          .          .           .          .          .           #if __cplusplus >= 201103L
          .          .          .                    .          .          .           .          .          .           	_GLIBCXX20_CONSTEXPR
          .          .          .                    .          .          .           .          .          .           	_Vector_impl_data(_Vector_impl_data&& __x) noexcept
          .          .          .                    .          .          .           .          .          .           	: _M_start(__x._M_start), _M_finish(__x._M_finish),
          .          .          .                    .          .          .           .          .          .           	  _M_end_of_storage(__x._M_end_of_storage)
          .          .          .                    .          .          .           .          .          .           	{ __x._M_start = __x._M_finish = __x._M_end_of_storage = pointer(); }
-- line 108 ----------------------------------------
-- line 359 ----------------------------------------
          .          .          .                    .          .          .           .          .          .                 : _M_impl(_Tp_alloc_type(__a), std::move(__x._M_impl))
          .          .          .                    .          .          .           .          .          .                 { }
          .          .          .                    .          .          .           .          .          .           #endif
          .          .          .                    .          .          .           .          .          .           
          .          .          .                    .          .          .           .          .          .                 _GLIBCXX20_CONSTEXPR
          .          .          .                    .          .          .           .          .          .                 ~_Vector_base() _GLIBCXX_NOEXCEPT
          .          .          .                    .          .          .           .          .          .                 {
          .          .          .                    .          .          .           .          .          .           	_M_deallocate(_M_impl._M_start,
         10 ( 0.00%) 1 ( 0.03%) 1 ( 0.04%)           5 ( 0.00%) 0          0           0          0          0           		      _M_impl._M_end_of_storage - _M_impl._M_start);
          .          .          .                    .          .          .           .          .          .                 }
          .          .          .                    .          .          .           .          .          .           
          .          .          .                    .          .          .           .          .          .               public:
          .          .          .                    .          .          .           .          .          .                 _Vector_impl _M_impl;
          .          .          .                    .          .          .           .          .          .           
          .          .          .                    .          .          .           .          .          .                 _GLIBCXX20_CONSTEXPR
          .          .          .                    .          .          .           .          .          .                 pointer
          .          .          .                    .          .          .           .          .          .                 _M_allocate(size_t __n)
          .          .          .                    .          .          .           .          .          .                 {
          .          .          .                    .          .          .           .          .          .           	typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
         12 ( 0.00%) 1 ( 0.03%) 1 ( 0.04%)           0          0          0           0          0          0           	return __n != 0 ? _Tr::allocate(_M_impl, __n) : pointer();
          .          .          .                    .          .          .           .          .          .                 }
          .          .          .                    .          .          .           .          .          .           
          .          .          .                    .          .          .           .          .          .                 _GLIBCXX20_CONSTEXPR
          .          .          .                    .          .          .           .          .          .                 void
          .          .          .                    .          .          .           .          .          .                 _M_deallocate(pointer __p, size_t __n)
          .          .          .                    .          .          .           .          .          .                 {
          .          .          .                    .          .          .           .          .          .           	typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
         14 ( 0.00%) 0          0                    0          0          0           0          0          0           	if (__p)
          .          .          .                    .          .          .           .          .          .           	  _Tr::deallocate(_M_impl, __p, __n);
          .          .          .                    .          .          .           .          .          .                 }
          .          .          .                    .          .          .           .          .          .           
          .          .          .                    .          .          .           .          .          .               protected:
          .          .          .                    .          .          .           .          .          .                 _GLIBCXX20_CONSTEXPR
          .          .          .                    .          .          .           .          .          .                 void
          .          .          .                    .          .          .           .          .          .                 _M_create_storage(size_t __n)
          .          .          .                    .          .          .           .          .          .                 {
          5 ( 0.00%) 0          0                    0          0          0           5 ( 0.00%) 0          0           	this->_M_impl._M_start = this->_M_allocate(__n);
          .          .          .                    .          .          .           .          .          .           	this->_M_impl._M_finish = this->_M_impl._M_start;
         15 ( 0.00%) 0          0                    0          0          0           5 ( 0.00%) 0          0           	this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
          .          .          .                    .          .          .           .          .          .                 }
          .          .          .                    .          .          .           .          .          .               };
          .          .          .                    .          .          .           .          .          .           
          .          .          .                    .          .          .           .          .          .             /**
          .          .          .                    .          .          .           .          .          .              *  @brief A standard container which offers fixed time access to
          .          .          .                    .          .          .           .          .          .              *  individual elements in any order.
          .          .          .                    .          .          .           .          .          .              *
          .          .          .                    .          .          .           .          .          .              *  @ingroup sequences
-- line 405 ----------------------------------------
-- line 556 ----------------------------------------
          .          .          .                    .          .          .           .          .          .                  *  @brief  Creates a %vector with copies of an exemplar element.
          .          .          .                    .          .          .           .          .          .                  *  @param  __n  The number of elements to initially create.
          .          .          .                    .          .          .           .          .          .                  *  @param  __value  An element to copy.
          .          .          .                    .          .          .           .          .          .                  *  @param  __a  An allocator.
          .          .          .                    .          .          .           .          .          .                  *
          .          .          .                    .          .          .           .          .          .                  *  This constructor fills the %vector with @a __n copies of @a __value.
          .          .          .                    .          .          .           .          .          .                  */
          .          .          .                    .          .          .           .          .          .                 _GLIBCXX20_CONSTEXPR
         15 ( 0.00%) 0          0                    0          0          0          15 ( 0.00%) 0          0                 vector(size_type __n, const value_type& __value,
          .          .          .                    .          .          .           .          .          .           	     const allocator_type& __a = allocator_type())
          .          .          .                    .          .          .           .          .          .                 : _Base(_S_check_init_len(__n, __a), __a)
         20 ( 0.00%) 0          0                   20 ( 0.00%) 0          0           0          0          0                 { _M_fill_initialize(__n, __value); }
          .          .          .                    .          .          .           .          .          .           #else
          .          .          .                    .          .          .           .          .          .                 /**
          .          .          .                    .          .          .           .          .          .                  *  @brief  Creates a %vector with copies of an exemplar element.
          .          .          .                    .          .          .           .          .          .                  *  @param  __n  The number of elements to initially create.
          .          .          .                    .          .          .           .          .          .                  *  @param  __value  An element to copy.
          .          .          .                    .          .          .           .          .          .                  *  @param  __a  An allocator.
          .          .          .                    .          .          .           .          .          .                  *
          .          .          .                    .          .          .           .          .          .                  *  This constructor fills the %vector with @a __n copies of @a __value.
-- line 575 ----------------------------------------
-- line 722 ----------------------------------------
          .          .          .                    .          .          .           .          .          .                  *  The dtor only erases the elements, and note that if the
          .          .          .                    .          .          .           .          .          .                  *  elements themselves are pointers, the pointed-to memory is
          .          .          .                    .          .          .           .          .          .                  *  not touched in any way.  Managing the pointer is the user's
          .          .          .                    .          .          .           .          .          .                  *  responsibility.
          .          .          .                    .          .          .           .          .          .                  */
          .          .          .                    .          .          .           .          .          .                 _GLIBCXX20_CONSTEXPR
          .          .          .                    .          .          .           .          .          .                 ~vector() _GLIBCXX_NOEXCEPT
          .          .          .                    .          .          .           .          .          .                 {
          5 ( 0.00%) 1 ( 0.03%) 1 ( 0.04%)           5 ( 0.00%) 0          0           0          0          0           	std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
          .          .          .                    .          .          .           .          .          .           		      _M_get_Tp_allocator());
          .          .          .                    .          .          .           .          .          .           	_GLIBCXX_ASAN_ANNOTATE_BEFORE_DEALLOC;
          .          .          .                    .          .          .           .          .          .                 }
          .          .          .                    .          .          .           .          .          .           
          .          .          .                    .          .          .           .          .          .                 /**
          .          .          .                    .          .          .           .          .          .                  *  @brief  %Vector assignment operator.
          .          .          .                    .          .          .           .          .          .                  *  @param  __x  A %vector of identical element and allocator types.
          .          .          .                    .          .          .           .          .          .                  *
-- line 738 ----------------------------------------
-- line 980 ----------------------------------------
          .          .          .                    .          .          .           .          .          .                 { return const_reverse_iterator(begin()); }
          .          .          .                    .          .          .           .          .          .           #endif
          .          .          .                    .          .          .           .          .          .           
          .          .          .                    .          .          .           .          .          .                 // [23.2.4.2] capacity
          .          .          .                    .          .          .           .          .          .                 /**  Returns the number of elements in the %vector.  */
          .          .          .                    .          .          .           .          .          .                 _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR
          .          .          .                    .          .          .           .          .          .                 size_type
          .          .          .                    .          .          .           .          .          .                 size() const _GLIBCXX_NOEXCEPT
         15 ( 0.00%) 0          0                    7 ( 0.00%) 1 ( 0.01%) 0           2 ( 0.00%) 0          0                 { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
          .          .          .                    .          .          .           .          .          .           
          .          .          .                    .          .          .           .          .          .                 /**  Returns the size() of the largest possible %vector.  */
          .          .          .                    .          .          .           .          .          .                 _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR
          .          .          .                    .          .          .           .          .          .                 size_type
          .          .          .                    .          .          .           .          .          .                 max_size() const _GLIBCXX_NOEXCEPT
          .          .          .                    .          .          .           .          .          .                 { return _S_max_size(_M_get_Tp_allocator()); }
          .          .          .                    .          .          .           .          .          .           
          .          .          .                    .          .          .           .          .          .           #if __cplusplus >= 201103L
-- line 996 ----------------------------------------
-- line 1116 ----------------------------------------
          .          .          .                    .          .          .           .          .          .                  *  out_of_range lookups are not defined. (For checked lookups
          .          .          .                    .          .          .           .          .          .                  *  see at().)
          .          .          .                    .          .          .           .          .          .                  */
          .          .          .                    .          .          .           .          .          .                 _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR
          .          .          .                    .          .          .           .          .          .                 reference
          .          .          .                    .          .          .           .          .          .                 operator[](size_type __n) _GLIBCXX_NOEXCEPT
          .          .          .                    .          .          .           .          .          .                 {
          .          .          .                    .          .          .           .          .          .           	__glibcxx_requires_subscript(__n);
478,402,264 ( 2.53%) 1 ( 0.03%) 1 ( 0.04%) 239,200,470 ( 6.23%) 0          0           1 ( 0.00%) 0          0           	return *(this->_M_impl._M_start + __n);
          .          .          .                    .          .          .           .          .          .                 }
          .          .          .                    .          .          .           .          .          .           
          .          .          .                    .          .          .           .          .          .                 /**
          .          .          .                    .          .          .           .          .          .                  *  @brief  Subscript access to the data contained in the %vector.
          .          .          .                    .          .          .           .          .          .                  *  @param __n The index of the element for which data should be
          .          .          .                    .          .          .           .          .          .                  *  accessed.
          .          .          .                    .          .          .           .          .          .                  *  @return  Read-only (constant) reference to data.
          .          .          .                    .          .          .           .          .          .                  *
-- line 1132 ----------------------------------------
-- line 1693 ----------------------------------------
          .          .          .                    .          .          .           .          .          .           	}
          .          .          .                    .          .          .           .          .          .           
          .          .          .                    .          .          .           .          .          .                 // Called by the first initialize_dispatch above and by the
          .          .          .                    .          .          .           .          .          .                 // vector(n,value,a) constructor.
          .          .          .                    .          .          .           .          .          .                 _GLIBCXX20_CONSTEXPR
          .          .          .                    .          .          .           .          .          .                 void
          .          .          .                    .          .          .           .          .          .                 _M_fill_initialize(size_type __n, const value_type& __value)
          .          .          .                    .          .          .           .          .          .                 {
          5 ( 0.00%) 0          0                    0          0          0           5 ( 0.00%) 0          0           	this->_M_impl._M_finish =
          .          .          .                    .          .          .           .          .          .           	  std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value,
          .          .          .                    .          .          .           .          .          .           					_M_get_Tp_allocator());
          .          .          .                    .          .          .           .          .          .                 }
          .          .          .                    .          .          .           .          .          .           
          .          .          .                    .          .          .           .          .          .           #if __cplusplus >= 201103L
          .          .          .                    .          .          .           .          .          .                 // Called by the vector(n) constructor.
          .          .          .                    .          .          .           .          .          .                 _GLIBCXX20_CONSTEXPR
          .          .          .                    .          .          .           .          .          .                 void
-- line 1709 ----------------------------------------
-- line 1896 ----------------------------------------
          .          .          .                    .          .          .           .          .          .           	const size_type __len = size() + (std::max)(size(), __n);
          .          .          .                    .          .          .           .          .          .           	return (__len < size() || __len > max_size()) ? max_size() : __len;
          .          .          .                    .          .          .           .          .          .                 }
          .          .          .                    .          .          .           .          .          .           
          .          .          .                    .          .          .           .          .          .                 // Called by constructors to check initial size.
          .          .          .                    .          .          .           .          .          .                 static _GLIBCXX20_CONSTEXPR size_type
          .          .          .                    .          .          .           .          .          .                 _S_check_init_len(size_type __n, const allocator_type& __a)
          .          .          .                    .          .          .           .          .          .                 {
         18 ( 0.00%) 1 ( 0.03%) 0                    0          0          0           0          0          0           	if (__n > _S_max_size(_Tp_alloc_type(__a)))
          .          .          .                    .          .          .           .          .          .           	  __throw_length_error(
          .          .          .                    .          .          .           .          .          .           	      __N("cannot create std::vector larger than max_size()"));
          .          .          .                    .          .          .           .          .          .           	return __n;
          .          .          .                    .          .          .           .          .          .                 }
          .          .          .                    .          .          .           .          .          .           
          .          .          .                    .          .          .           .          .          .                 static _GLIBCXX20_CONSTEXPR size_type
          .          .          .                    .          .          .           .          .          .                 _S_max_size(const _Tp_alloc_type& __a) _GLIBCXX_NOEXCEPT
          .          .          .                    .          .          .           .          .          .                 {
-- line 1912 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/jovyan/Proyecto-intermedio-entropia/code/random_movement.cpp
--------------------------------------------------------------------------------
Ir                     I1mr       ILmr       Dr                   D1mr       DLmr       Dw                   D1mw       DLmw       

            .          .          .                    .          .          .                    .          .          .           #include "random_movement.hpp"
            .          .          .                    .          .          .                    .          .          .           
    5,382,000 ( 0.03%) 2 ( 0.06%) 2 ( 0.08%)           0          0          0            4,784,000 ( 0.66%) 0          0           void random_movement(int &dim, int &n_molecules, int &lattice_size, std::vector<double> &molecules, std::mt19937 &gen, std::uniform_int_distribution<int> &direction_distribution, int &problem_id, int &count_out){
            .          .          .                    .          .          .                    .          .          .           
            .          .          .                    .          .          .                    .          .          .               // The constant movement passage of the simulation is defined
            .          .          .                    .          .          .                    .          .          .               double step_size = 0.005;
            .          .          .                    .          .          .                    .          .          .           
            .          .          .                    .          .          .                    .          .          .               // Definition of constants for particle movement
            .          .          .                    .          .          .                    .          .          .               int pos_x = 0, pos_y = 1;
            .          .          .                    .          .          .                    .          .          .               int direction = 0;
    2,990,000 ( 0.02%) 0          0            1,196,000 ( 0.03%) 0          0              598,000 ( 0.08%) 0          0               double limit = lattice_size/2.0; // Limit for a centered coordinate system
    1,196,000 ( 0.01%) 0          0              598,000 ( 0.02%) 0          0              598,000 ( 0.08%) 0          0               double m_limit = -1.0*limit;
            .          .          .                    .          .          .                    .          .          .           
    1,196,000 ( 0.01%) 0          0              598,000 ( 0.02%) 1 ( 0.01%) 1 ( 0.01%)           0          0          0           	double hole = lattice_size/10.0;
    1,196,000 ( 0.01%) 0          0                    0          0          0              598,000 ( 0.08%) 0          0               double out = 2.0*lattice_size;
            .          .          .                    .          .          .                    .          .          .           
            .          .          .                    .          .          .                    .          .          .               // For contact with the wall or position outside the box, the movement in that direction is reflected twice
            .          .          .                    .          .          .                    .          .          .               double step_backward = 2.0*step_size; 
            .          .          .                    .          .          .                    .          .          .           
  962,780,000 ( 5.08%) 2 ( 0.06%) 2 ( 0.08%) 478,998,000 (12.47%) 0          0              598,000 ( 0.08%) 0          0               for (int i = 0; i < n_molecules; i++){
            .          .          .                    .          .          .                    .          .          .                   direction = direction_distribution(gen);
  956,800,000 ( 5.05%) 0          0          478,400,000 (12.45%) 0          0                    0          0          0           		if ((problem_id == 4) && (molecules[i*dim + pos_x] == out)) { direction = 4;}
            .          .          .                    .          .          .                    .          .          .           
1,016,588,624 ( 5.37%) 1 ( 0.03%) 1 ( 0.04%)           0          0          0                    0          0          0                   switch (direction) {
            .          .          .                    .          .          .                    .          .          .                       case 0: // Up
  299,007,790 ( 1.58%) 0          0          119,603,116 ( 3.11%) 0          0                    0          0          0                           molecules[i*dim + pos_y] += step_size;
            .          .          .                    .          .          .                    .          .          .                           if (molecules[i*dim + pos_y] >= limit) molecules[i*dim + pos_y] -= step_backward;
            .          .          .                    .          .          .                    .          .          .                           break;
            .          .          .                    .          .          .                    .          .          .           
            .          .          .                    .          .          .                    .          .          .                       case 1: // Down
  538,069,170 ( 2.84%) 0          0          239,146,888 ( 6.23%) 0          0           59,781,058 ( 8.21%) 0          0                           molecules[i*dim + pos_y] -= step_size;
  179,360,166 ( 0.95%) 0          0           59,786,722 ( 1.56%) 0          0                    0          0          0                           if (molecules[i*dim + pos_y] <= m_limit) {
       11,328 ( 0.00%) 0          0                5,664 ( 0.00%) 0          0                5,664 ( 0.00%) 0          0           					molecules[i*dim + pos_y] += step_backward;
       11,328 ( 0.00%) 1 ( 0.03%) 1 ( 0.04%)           0          0          0                    0          0          0           					if ((problem_id == 4) && (std::fabs(molecules[i*dim + pos_x]) < hole)) {
            .          .          .                    .          .          .                    .          .          .           						molecules[i*dim + pos_x] = out;
            .          .          .                    .          .          .                    .          .          .           						count_out++;
            .          .          .                    .          .          .                    .          .          .           					} 
            .          .          .                    .          .          .                    .          .          .           				}
            .          .          .                    .          .          .                    .          .          .           				break;
            .          .          .                    .          .          .                    .          .          .           
            .          .          .                    .          .          .                    .          .          .                       case 2: // Left
  358,822,752 ( 1.89%) 1 ( 0.03%) 1 ( 0.04%) 239,215,168 ( 6.23%) 0          0                    0          0          0                           molecules[i*dim + pos_x] -= step_size;
  179,438,079 ( 0.95%) 0          0           59,812,693 ( 1.56%) 0          0                8,901 ( 0.00%) 0          0                           if (molecules[i*dim + pos_x] <= m_limit) molecules[i*dim + pos_x] += step_backward;
            .          .          .                    .          .          .                    .          .          .                           break;
            .          .          .                    .          .          .                    .          .          .           
            .          .          .                    .          .          .                    .          .          .                       case 3: // Right
  538,252,242 ( 2.84%) 0          0          358,834,828 ( 9.34%) 0          0                    0          0          0                           molecules[i*dim + pos_x] += step_size;
  598,044,756 ( 3.16%) 1 ( 0.03%) 1 ( 0.04%) 119,626,516 ( 3.11%) 0          0          179,404,377 (24.63%) 0          0                           if (molecules[i*dim + pos_x] >= limit) molecules[i*dim + pos_x] -= step_backward;
            .          .          .                    .          .          .                    .          .          .                           break;
            .          .          .                    .          .          .                    .          .          .           
            .          .          .                    .          .          .                    .          .          .           			default:
            .          .          .                    .          .          .                    .          .          .           				break;
            .          .          .                    .          .          .                    .          .          .                   }
            .          .          .                    .          .          .                    .          .          .               }   
    4,784,002 ( 0.03%) 0          0            4,186,001 ( 0.11%) 0          0                    1 ( 0.00%) 0          0           }
--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/12/bits/uniform_int_dist.h
--------------------------------------------------------------------------------
Ir                   I1mr       ILmr       Dr                   D1mr       DLmr       Dw         D1mw       DLmw       

-- line 87 ----------------------------------------
          .          .          .                    .          .          .          .          .          .                 {
          .          .          .                    .          .          .          .          .          .           	typedef uniform_int_distribution<_IntType> distribution_type;
          .          .          .                    .          .          .          .          .          .           
          .          .          .                    .          .          .          .          .          .           	param_type() : param_type(0) { }
          .          .          .                    .          .          .          .          .          .           
          .          .          .                    .          .          .          .          .          .           	explicit
          .          .          .                    .          .          .          .          .          .           	param_type(_IntType __a,
          .          .          .                    .          .          .          .          .          .           		   _IntType __b = __gnu_cxx::__int_traits<_IntType>::__max)
          2 ( 0.00%) 0          0                    1 ( 0.00%) 0          0          1 ( 0.00%) 0          0           	: _M_a(__a), _M_b(__b)
          .          .          .                    .          .          .          .          .          .           	{
          .          .          .                    .          .          .          .          .          .           	  __glibcxx_assert(_M_a <= _M_b);
          .          .          .                    .          .          .          .          .          .           	}
          .          .          .                    .          .          .          .          .          .           
          .          .          .                    .          .          .          .          .          .           	result_type
          .          .          .                    .          .          .          .          .          .           	a() const
          .          .          .                    .          .          .          .          .          .           	{ return _M_a; }
          .          .          .                    .          .          .          .          .          .           
-- line 103 ----------------------------------------
-- line 184 ----------------------------------------
          .          .          .                    .          .          .          .          .          .                 max() const
          .          .          .                    .          .          .          .          .          .                 { return this->b(); }
          .          .          .                    .          .          .          .          .          .           
          .          .          .                    .          .          .          .          .          .                 /**
          .          .          .                    .          .          .          .          .          .                  * @brief Generating functions.
          .          .          .                    .          .          .          .          .          .                  */
          .          .          .                    .          .          .          .          .          .                 template<typename _UniformRandomBitGenerator>
          .          .          .                    .          .          .          .          .          .           	result_type
239,200,000 ( 1.26%) 0          0          239,200,000 ( 6.23%) 0          0          0          0          0           	operator()(_UniformRandomBitGenerator& __urng)
          .          .          .                    .          .          .          .          .          .                   { return this->operator()(__urng, _M_param); }
          .          .          .                    .          .          .          .          .          .           
          .          .          .                    .          .          .          .          .          .                 template<typename _UniformRandomBitGenerator>
          .          .          .                    .          .          .          .          .          .           	result_type
          .          .          .                    .          .          .          .          .          .           	operator()(_UniformRandomBitGenerator& __urng,
          .          .          .                    .          .          .          .          .          .           		   const param_type& __p);
          .          .          .                    .          .          .          .          .          .           
          .          .          .                    .          .          .          .          .          .                 template<typename _ForwardIterator,
-- line 200 ----------------------------------------
-- line 250 ----------------------------------------
          .          .          .                    .          .          .          .          .          .           	  static_assert(!_Up_traits::__is_signed, "U must be unsigned");
          .          .          .                    .          .          .          .          .          .           	  static_assert(!_Wp_traits::__is_signed, "W must be unsigned");
          .          .          .                    .          .          .          .          .          .           	  static_assert(_Wp_traits::__digits == (2 * _Up_traits::__digits),
          .          .          .                    .          .          .          .          .          .           			"W must be twice as wide as U");
          .          .          .                    .          .          .          .          .          .           
          .          .          .                    .          .          .          .          .          .           	  // reference: Fast Random Integer Generation in an Interval
          .          .          .                    .          .          .          .          .          .           	  // ACM Transactions on Modeling and Computer Simulation 29 (1), 2019
          .          .          .                    .          .          .          .          .          .           	  // https://arxiv.org/abs/1805.10941
239,200,000 ( 1.26%) 0          0                    0          0          0          0          0          0           	  _Wp __product = _Wp(__g()) * _Wp(__range);
          .          .          .                    .          .          .          .          .          .           	  _Up __low = _Up(__product);
478,400,000 ( 2.53%) 0          0                    0          0          0          0          0          0           	  if (__low < __range)
          .          .          .                    .          .          .          .          .          .           	    {
          .          .          .                    .          .          .          .          .          .           	      _Up __threshold = -__range % __range;
          .          .          .                    .          .          .          .          .          .           	      while (__low < __threshold)
          .          .          .                    .          .          .          .          .          .           		{
          .          .          .                    .          .          .          .          .          .           		  __product = _Wp(__g()) * _Wp(__range);
          .          .          .                    .          .          .          .          .          .           		  __low = _Up(__product);
          .          .          .                    .          .          .          .          .          .           		}
          .          .          .                    .          .          .          .          .          .           	    }
717,600,000 ( 3.79%) 2 ( 0.06%) 2 ( 0.08%)           0          0          0          0          0          0           	  return __product >> _Up_traits::__digits;
          .          .          .                    .          .          .          .          .          .           	}
          .          .          .                    .          .          .          .          .          .               };
          .          .          .                    .          .          .          .          .          .           
          .          .          .                    .          .          .          .          .          .             template<typename _IntType>
          .          .          .                    .          .          .          .          .          .               template<typename _UniformRandomBitGenerator>
          .          .          .                    .          .          .          .          .          .                 typename uniform_int_distribution<_IntType>::result_type
          .          .          .                    .          .          .          .          .          .                 uniform_int_distribution<_IntType>::
          .          .          .                    .          .          .          .          .          .                 operator()(_UniformRandomBitGenerator& __urng,
-- line 277 ----------------------------------------
-- line 282 ----------------------------------------
          .          .          .                    .          .          .          .          .          .           	typedef typename common_type<_Gresult_type, __utype>::type __uctype;
          .          .          .                    .          .          .          .          .          .           
          .          .          .                    .          .          .          .          .          .           	constexpr __uctype __urngmin = _UniformRandomBitGenerator::min();
          .          .          .                    .          .          .          .          .          .           	constexpr __uctype __urngmax = _UniformRandomBitGenerator::max();
          .          .          .                    .          .          .          .          .          .           	static_assert( __urngmin < __urngmax,
          .          .          .                    .          .          .          .          .          .           	    "Uniform random bit generator must define min() < max()");
          .          .          .                    .          .          .          .          .          .           	constexpr __uctype __urngrange = __urngmax - __urngmin;
          .          .          .                    .          .          .          .          .          .           
478,400,000 ( 2.53%) 0          0                    0          0          0          0          0          0           	const __uctype __urange
478,400,000 ( 2.53%) 0          0          239,200,000 ( 6.23%) 0          0          0          0          0           	  = __uctype(__param.b()) - __uctype(__param.a());
          .          .          .                    .          .          .          .          .          .           
          .          .          .                    .          .          .          .          .          .           	__uctype __ret;
717,600,000 ( 3.79%) 0          0                    0          0          0          0          0          0           	if (__urngrange > __urange)
          .          .          .                    .          .          .          .          .          .           	  {
          .          .          .                    .          .          .          .          .          .           	    // downscaling
          .          .          .                    .          .          .          .          .          .           
239,200,000 ( 1.26%) 0          0                    0          0          0          0          0          0           	    const __uctype __uerange = __urange + 1; // __urange can be zero
          .          .          .                    .          .          .          .          .          .           
          .          .          .                    .          .          .          .          .          .           #if defined __UINT64_TYPE__ && defined __UINT32_TYPE__
          .          .          .                    .          .          .          .          .          .           #if __SIZEOF_INT128__
          .          .          .                    .          .          .          .          .          .           	    if _GLIBCXX17_CONSTEXPR (__urngrange == __UINT64_MAX__)
          .          .          .                    .          .          .          .          .          .           	      {
          .          .          .                    .          .          .          .          .          .           		// __urng produces values that use exactly 64-bits,
          .          .          .                    .          .          .          .          .          .           		// so use 128-bit integers to downscale to desired range.
          .          .          .                    .          .          .          .          .          .           		__UINT64_TYPE__ __u64erange = __uerange;
-- line 306 ----------------------------------------
-- line 308 ----------------------------------------
          .          .          .                    .          .          .          .          .          .           							       __u64erange);
          .          .          .                    .          .          .          .          .          .           	      }
          .          .          .                    .          .          .          .          .          .           	    else
          .          .          .                    .          .          .          .          .          .           #endif
          .          .          .                    .          .          .          .          .          .           	    if _GLIBCXX17_CONSTEXPR (__urngrange == __UINT32_MAX__)
          .          .          .                    .          .          .          .          .          .           	      {
          .          .          .                    .          .          .          .          .          .           		// __urng produces values that use exactly 32-bits,
          .          .          .                    .          .          .          .          .          .           		// so use 64-bit integers to downscale to desired range.
239,200,000 ( 1.26%) 0          0                    0          0          0          0          0          0           		__UINT32_TYPE__ __u32erange = __uerange;
          .          .          .                    .          .          .          .          .          .           		__ret = _S_nd<__UINT64_TYPE__>(__urng, __u32erange);
          .          .          .                    .          .          .          .          .          .           	      }
          .          .          .                    .          .          .          .          .          .           	    else
          .          .          .                    .          .          .          .          .          .           #endif
          .          .          .                    .          .          .          .          .          .           	      {
          .          .          .                    .          .          .          .          .          .           		// fallback case (2 divisions)
          .          .          .                    .          .          .          .          .          .           		const __uctype __scaling = __urngrange / __uerange;
          .          .          .                    .          .          .          .          .          .           		const __uctype __past = __uerange * __scaling;
-- line 324 ----------------------------------------
-- line 353 ----------------------------------------
          .          .          .                    .          .          .          .          .          .           			 (__urng, param_type(0, __urange / __uerngrange)));
          .          .          .                    .          .          .          .          .          .           		__ret = __tmp + (__uctype(__urng()) - __urngmin);
          .          .          .                    .          .          .          .          .          .           	      }
          .          .          .                    .          .          .          .          .          .           	    while (__ret > __urange || __ret < __tmp);
          .          .          .                    .          .          .          .          .          .           	  }
          .          .          .                    .          .          .          .          .          .           	else
          .          .          .                    .          .          .          .          .          .           	  __ret = __uctype(__urng()) - __urngmin;
          .          .          .                    .          .          .          .          .          .           
239,200,000 ( 1.26%) 1 ( 0.03%) 1 ( 0.04%)           0          0          0          0          0          0           	return __ret + __param.a();
          .          .          .                    .          .          .          .          .          .                 }
          .          .          .                    .          .          .          .          .          .           
          .          .          .                    .          .          .          .          .          .           
          .          .          .                    .          .          .          .          .          .             template<typename _IntType>
          .          .          .                    .          .          .          .          .          .               template<typename _ForwardIterator,
          .          .          .                    .          .          .          .          .          .           	     typename _UniformRandomBitGenerator>
          .          .          .                    .          .          .          .          .          .                 void
          .          .          .                    .          .          .          .          .          .                 uniform_int_distribution<_IntType>::
-- line 369 ----------------------------------------

--------------------------------------------------------------------------------
Ir                      I1mr        ILmr        Dr                     D1mr       DLmr       Dw                   D1mw        DLmw       
--------------------------------------------------------------------------------
18,926,244,085 (99.94%) 26 ( 0.81%) 24 ( 0.99%) 3,837,092,274 (99.88%) 2 ( 0.02%) 1 ( 0.01%) 726,310,423 (99.70%) 74 ( 2.99%) 0           events annotated

